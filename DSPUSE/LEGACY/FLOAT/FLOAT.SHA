#!/bin/sh
# This is a shell archive (shar 3.32)
# made 10/14/1992 17:44 UTC by johnf@what
# Source directory /tmp_mnt/auto/home_dsp/users/johnf/dspcode/bubfiles/56000/float
#
# existing files WILL be overwritten
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   5786 -rw-r--r-- durbin.asm
#   2021 -rw-r--r-- fpabs.asm
#   3974 -rw-r--r-- fpadd.asm
#   1819 -rw-r--r-- fpceil.asm
#   2693 -rw-r--r-- fpcmp.asm
#   3937 -rw-r--r-- fpdiv.asm
#   4061 -rw-r--r-- fpfix.asm
#   2123 -rw-r--r-- fpfloat.asm
#   2009 -rw-r--r-- fpfloor.asm
#   1938 -rw-r--r-- fpfrac.asm
#   2396 -rw-r--r-- fpinit.asm
#   1673 -rw-r--r-- fplist.asm
#   2800 -rw-r--r-- fpmac.asm
#   2328 -rw-r--r-- fpmpy.asm
#   2099 -rw-r--r-- fpneg.asm
#   2203 -rw-r--r-- fpscale.asm
#   2961 -rw-r--r-- fpsqrt.asm
#   3170 -rw-r--r-- fpsub.asm
#   3017 -rw-r--r-- durbin.hlp
#  12166 -rw-r--r-- fpcalls.hlp
#  10835 -rw-r--r-- fpdef.hlp
#   1848 -rw-r--r-- fprevs.hlp
#
if touch 2>&1 | fgrep 'amc' > /dev/null
 then TOUCH=touch
 else TOUCH=true
fi
# ============= durbin.asm ==============
echo "x - extracting durbin.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > durbin.asm &&
X;
X; This program, originally available on the Motorola DSP bulletin board,
X; is provided under a DISCLAIMER OF WARRANTY available from Motorola DSP
X; Operation, 6501 William Cannon Drive West, Austin, Texas  78735-8598.
X;
X;       DURBIN's recursive solution of linear predictive coefficients (LPC)
X;       using the floating point library.
X;
X;       Execution time for a 10th order system: 855 uS (in floating point)
X;
X;       Version 1.0      10-Nov-87
X;
X        opt     nomd,mex,mu,cre
X        page    132,60,1,1
X;
X;       Durbin's recursive LPC solution
X;
X        define  fp_space 'x'
Xncoef   equ     10              ;10th order system
X        org     l:0
Xeng     ds      1               ;energy
Xk       ds      1               ;temporary reflection coefficient
Xanew    ds      ncoef           ;temporary predictor coefficients
Xalpha   ds      ncoef           ;final predictor coefficients
Xcoef    equ     *
Xrn      ds      ncoef+1         ;autocorrelation coefficients
X 
X;
X;       overlay the data into the "rn" array in long memory
X;
X        org     x:coef          ;mantissas of rn data
X        dc      $400000         ;r(0)=1.0
X        dc      $533333         ;r(1)=.65
X        dc      $4ccccd         ;r(2)=.6
X        dc      $400000         ;r(3)=.5
X        dc      $666666         ;r(4)=.1
X        dc      $666666         ;r(5)=.1
X        dc      $99999a         ;r(6)=-.05
X        dc      $851eb9         ;r(7)=-.03
X        dc      $99999a         ;r(8)=-.05
X        dc      $b851ec         ;r(9)=-.07
X        dc      $51eb85         ;r(10)=.01
X;
X;       Define the starting address for the data and scratch pad for
X;       the floating point subroutines
X;
Xfp_temp equ     *               ;define address of fp space
X 
X        org     y:coef          ;exponents of rn values
X        dc      $2000
X        dc      $1fff
X        dc      $1fff
X        dc      $1fff
X        dc      $1ffc
X        dc      $1ffc
X        dc      $1ffb
X        dc      $1ffa
X        dc      $1ffb
X        dc      $1ffc
X        dc      $1ff9
X 
X;
X;       define floating point routines
X;
X        org     p:$100
X        nolist
X        page
X        include 'dsplib:fpinit'
X        page
X        include 'dsplib:fpadd'
X        page
X        include 'dsplib:fpsub'
X        page
X        include 'dsplib:fpcmp'
X        page
X        include 'dsplib:fpmpy'
X        page
X        include 'dsplib:fpmac'
X        page
X        include 'dsplib:fpdiv'
X        page
X        include 'dsplib:fpsqrt'
X        page
X        include 'dsplib:fpneg'
X        page
X        include 'dsplib:fpabs'
X        page
X        include 'dsplib:fpscale'
X        page
X        include 'dsplib:fpfix'
X        page
X        include 'dsplib:fpfloat'
X        list
X 
X        org     p:$500
Xstart
X        jsr     fpinit          ;initialize floating point library
X 
X        move    l:rn,x          ;get rn(0)
X        move    x,l:eng         ;eng=rn(0)
X        move    l:rn+1,y        ;get rn(1)
X        jsr     fdiv_xy         ;rn(1)/rn(0)
X        move    ab,l:alpha      ;alpha(1)=rn(1)/rn(0)
X        move    a,x1            ;copy alpha(1)
X        move    b,x0
X        move    a,y1            ;copy alpha(1) to y
X        move    b,y0
X        move    #$400000,a      ;1.0
X        move    #$2000,b        ;exponent of 1.0
X        jsr     fmac_mxya       ;1.0-alpha(1)*alpha(1)
X        move    l:eng,x         ;get eng
X        jsr     fmpy_xa         ;*eng
X        move    ab,l:eng        ;save new eng
X 
X        move    #1,r1           ;m
X        move    #rn+2,r6        ;point to rn(i)
X        move    #alpha+1,r7     ;point to alpha(i)
X 
X        do      #ncoef-1,_edurbin
X        move    #rn,r4          ;point to base of rn array
X        move    r1,n4           ;offset m
X        clr     a       #0,b    ;clear sum
X        lua     (r4)+n4,r4      ;generate iptr
X        move    #alpha,r5       ;point to alpha base
X        do      r1,_esum        ;generate sum
X        move    l:(r5)+,x       ;get alpha(j)
X        move    l:(r4)-,y       ;get rn(iptr)
X        jsr     fmac_xya        ;compute sum
X        nop
X_esum
X        move    a,x1            ;copy sum to x
X        move    b,x0
X        move    l:(r6)+,y       ;get rn(i), point to next
X        jsr     fsub_xy         ;do rn(i)-sum
X        move    l:eng,x         ;get eng
X        jsr     fdiv_xa         ;do (rn(i)-sum)/eng
X        move    ab,l:k          ;save as k
X        move    #alpha-1,r4     ;point to alpha base
X        move    ab,l:(r7)+      ;save as alpha(i), point to next
X        lua     (r4)+n4,r4      ;generate iptr
X        move    #alpha,r5       ;pointer for alpha(j)
X        move    #anew,r3        ;point to anew array
X        do      r1,_eupdate     ;update alphas
X        move    l:(r5)+,ab      ;get alpha(j)
X        move    l:k,x           ;get k
X        move    l:(r4)-,y       ;get alpha(iptr), dec iptr
X        jsr     fmac_mxya       ;alpha(j)-k*alpha(iptr)
X        move    ab,l:(r3)+      ;save anew(j)
X_eupdate
X        move    #anew,r4        ;point to anew array
X        move    #alpha,r5       ;point to alpha array
X        do      r1,_ecopy       ;copy anew to alpha
X        move    l:(r4)+,x       ;get anew(j)
X        move    x,l:(r5)+       ;save alpha(J)
X_ecopy
X        move    #$400000,a      ;get a 1.0
X        move    #$2000,b        ;exponent
X        move    l:k,x           ;get k
X        move    l:k,y           ;get k again
X        jsr     fmac_mxya       ;1.0-k*k
X        move    l:eng,x         ;get energy
X        jsr     fmpy_xa         ;(1.0-k*k)*eng
X        move    ab,l:eng        ;save new eng
X        move    (r1)+           ;increment m
X_edurbin
X        end
X 
X 
X 
X 
X
SHAR_EOF
$TOUCH -am 1126102891 durbin.asm &&
chmod 0644 durbin.asm ||
echo "restore of durbin.asm failed"
set `wc -c durbin.asm`;Wc_c=$1
if test "$Wc_c" != "5786"; then
	echo original size 5786, current size $Wc_c
fi
# ============= fpabs.asm ==============
echo "x - extracting fpabs.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpabs.asm &&
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 5 Oct 87   Version 2.0
X;
X; Entry points: fabs_a  R = absolute value(A)
X;               fabs_x  R = absolute value(X)
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X   x1 = mx  (normalized)
X;       x0 = ex
X;
X;   A   a2 = sign extension of ma
X;       a1 = ma  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of ea (always zero)
X;       b1 = ea
X;       b0 = zero
X;
X; Output variables:
X;
X;   R   a2 = sign extension of mr
X;       a1 = mr  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of er (always zero)
X;       b1 = er
X;       b0 = zero
X;
X; Error conditions:     Set CCR L=1 if floating point overflow.  Result
X;                       is set to the maximum floating point value of the
X;                       correct sign.  The CCR L bit remains set until
X;                       cleared by the user.
X;
X;                       Set CCR L=1 if floating point underflow.  Result
X;                       is set to floating point zero.  The CCR L bit
X;                       remains set until cleared by the user.
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;       x1      x0      y1      y0
X;
X; Alters Address Registers
X;       r0
X;
X; Alters Program Control Registers
X;       pc      sr
X;
X; Uses 0 locations on System Stack
X;
X;
Xfabs_x  tfr     x0,b    x1,a            ;get ex, mx
Xfabs_a  tst     a                       ;check for negative ma
X        jmi     fneg_a                  ;negate if negative
X        rts
X
SHAR_EOF
$TOUCH -am 1126102891 fpabs.asm &&
chmod 0644 fpabs.asm ||
echo "restore of fpabs.asm failed"
set `wc -c fpabs.asm`;Wc_c=$1
if test "$Wc_c" != "2021"; then
	echo original size 2021, current size $Wc_c
fi
# ============= fpadd.asm ==============
echo "x - extracting fpadd.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpadd.asm &&
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 7 Oct 87   Version 2.0
X;
Xfpadd   ident   2,0
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; FPADD - FLOATING POINT ADDITION SUBROUTINE
X;
X; Entry points: fadd_xa R = A + X
X;               fadd_xy R = Y + X
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X   x1 = mx  (normalized)
X;       x0 = ex
X;
X;   Y   y1 = my  (normalized)
X;       y0 = ey
X;
X;   A   a2 = sign extension of ma
X;       a1 = ma  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of ea (always zero)
X;       b1 = ea
X;       b0 = zero
X;
X; Output variables:
X;
X;   R   a2 = sign extension of mr
X;       a1 = mr  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of er (always zero)
X;       b1 = er
X;       b0 = zero
X;
X; Error conditions:     Set CCR L=1 if floating point overflow.  Result
X;                       is set to the maximum floating point value of the
X;                       correct sign.  The CCR L bit remains set until
X;                       cleared by the user.
X;
X;                       Set CCR L=1 if floating point underflow.  Result
X;                       is set to floating point zero.  The CCR L bit
X;                       remains set until cleared by the user.
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;       x1      x0      y1      y0
X;
X; Alters Address Registers
X;       r0
X;
X; Alters Program Control Registers
X;       pc      sr
X;
X; Uses 0 locations on System Stack
X;
X;
Xfadd_xy tfr     y0,b    y1,a            ;get ey, my
Xfadd_xa cmp     x0,b    fp_space:fp_23,y0       ;compare delta = er - ea,
X                                                ; get delta limit
X        jge     _dpos                   ;jump if er >= ea
X;
X; er < ea
X;
X_dneg   tfr     x1,a    a1,x1           ;swap ma with mr
X        tfr     x0,b    b1,x0           ;swap ea with er
X;
X; er >= ea
X;
X_dpos   sub     x0,b    b1,y1           ;calculate delta, save er'
X        cmp     y0,b    b1,r0           ;check delta limit, save delta
X        jgt     done1                   ;jump if delta > 23
Xaddm    move    fp_space:(r0+n0),x0     ;lookup shift constant s
X        mac     -x1,x0,a        y1,r0   ;denormalize by s, add mantissa, get er'
X        jmp     norm1                   ;try for quick normalization
X;
X; normalize and round result - assumes a=mr', r0=er' and CCR reflects mr' value.
X;
Xnorm    rep     #8                      ;normalize up to 8 bits left or right
Xnorm1   norm    r0,a                    ;shift 1 bit and update exponent by 1
X        jnn     norm                    ;jump if not normalized
Xround   rnd     a                       ;round to 24 bit mr
X        norm    r0,a                    ;correct mr overflow due to round
X;
X; detect and correct exceptions - assumes a=mr and r0=er
X;
Xcheck   move    r0,fp_space:fp_temp     ;check er
X        jset    #15,fp_space:fp_temp,under      ;jump if exponent underflow
X        jset    #14,fp_space:fp_temp,limit      ;jump if exponent overflow
Xcheck1  tst     a       r0,b            ;check mr, get er
X        teq     a,b                     ;if mr=0, correct to fp zero
X        rts
Xunder   or      #$40,ccr                ;set L=1 for exponent underflow
Xzero    clr     a       #0,b            ;correct to fp zero
X        rts
Xlimit   asl     a       fp_space:fp_emax,y1     ;correct to maximum fp value
Xdone1   tfr     y1,b    a,a             ;get mr and er, set L bit if mr limited
Xdone    rts
X
SHAR_EOF
$TOUCH -am 1126102891 fpadd.asm &&
chmod 0644 fpadd.asm ||
echo "restore of fpadd.asm failed"
set `wc -c fpadd.asm`;Wc_c=$1
if test "$Wc_c" != "3974"; then
	echo original size 3974, current size $Wc_c
fi
# ============= fpceil.asm ==============
echo "x - extracting fpceil.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpceil.asm &&
Xfpceil  ident   2,0
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; This program, originally available on the Motorola DSP bulletin board,
X; is provided under a DISCLAIMER OF WARRANTY available from Motorola DSP
X; Operation, 6501 William Cannon Drive, West, Austin, Texas  78735-8598.
X;
X; FPCEIL - FLOATING POINT CEIL SUBROUTINE
X;
X; Entry points: fceil_a    R = ceil(A)
X;               fceil_x    R = ceil(X)
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X   x1 = mx  (normalized)
X;       x0 = ex
X;
X;   A   a2 = sign extension of ma
X;       a1 = ma  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of ea (always zero)
X;       b1 = ea
X;       b0 = zero
X;
X; Output variables:
X;
X;   R   a2 = sign extension of mr
X;       a1 = mr  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of er (always zero)
X;       b1 = er
X;       b0 = zero
X;
X; Error conditions:     No error conditions are signaled.
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;       x1      x0
X;
X; Alters Address Registers
X;       r0
X;
X; Alters Program Control Registers
X;       pc      sr
X;       ssh     ssl     sp
X;
X; Uses 1 location on System Stack
X;
X; Version - 2.0
X; Latest Revision - February 22, 1988
X;
Xfceil_x tfr     x0,b    x1,a            ;get mx,ex
Xfceil_a
X        neg     a                       ;reverse number line
X        jsr     floor_a                 ;do floor operation
X        neg     a                       ;reverse number line
X        rts
X 
X 
X 
X 
X 
X
SHAR_EOF
$TOUCH -am 1126102891 fpceil.asm &&
chmod 0644 fpceil.asm ||
echo "restore of fpceil.asm failed"
set `wc -c fpceil.asm`;Wc_c=$1
if test "$Wc_c" != "1819"; then
	echo original size 1819, current size $Wc_c
fi
# ============= fpcmp.asm ==============
echo "x - extracting fpcmp.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpcmp.asm &&
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 3 Nov 87   Version 2.1
X;
Xfpcmp   ident   2,1
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; FPCMP - FLOATING POINT COMPARISON (SETS CONDITION CODES) SUBROUTINE
X;
X;
X; Entry points: fcmp_xa A - X   SET CONDITION CODES
X;               fcmp_xy Y - X   SET CONDITION CODES
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X   x1 = mx  (normalized)
X;       x0 = ex
X;
X;   Y   y1 = my  (normalized)
X;       y0 = ey
X;
X;   A   a2 = sign extension of ma
X;       a1 = ma  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of ea (always zero)
X;       b1 = ea
X;       b0 = zero
X;
X; Output variables:
X;
X;       The following Jcc branch conditions can be used after calling
X;       fcmp_xa or fcmp_xy.  The other branch conditions should not be used.
X;
X;       "cc" Mnemonic                   Condition
X;       -------------                   ---------
X;       EQ - equal                      Z = 1
X;       GE - greater than or equal      N eor V = 0
X;       GT - greater than               Z + (N eor V) = 0
X;       LE - less than or equal         Z + (N eor V) = 1
X;       LT - less than                  N eor V = 1
X;       NE - not equal                  Z = 0
X;
X; Error conditions:     none
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;               x0              y0
X;
X; Alters Address Registers
X;
X;
X; Alters Program Control Registers
X;       pc      sr
X;
X; Uses 0 locations on System Stack
X;
X;
Xfcmp_xy tfr     y0,b    y1,a            ;get ey, my
Xfcmp_xa eor     x1,a    a,y0            ;compare signs, save ma
X        jmi     _mant                   ;jump if different signs
X;
X; Same signs
X;
X_sign   eor     x1,a                    ;check sign of ma
X        jpl     _sign1                  ;jump if ma and mx positive
X        tfr     x0,b    b,x0            ;if minus, exchange ea and ex
X_sign1  cmp     x0,b                    ;compare exponents
X        jne     done                    ;jump if different exponents
X;
X; Same signs, same exponents or different signs
X;
X_mant   tfr     y0,a                    ;restore ma
X        cmp     x1,a                    ;compare mantissa
X        rts
X
SHAR_EOF
$TOUCH -am 1126102991 fpcmp.asm &&
chmod 0644 fpcmp.asm ||
echo "restore of fpcmp.asm failed"
set `wc -c fpcmp.asm`;Wc_c=$1
if test "$Wc_c" != "2693"; then
	echo original size 2693, current size $Wc_c
fi
# ============= fpdiv.asm ==============
echo "x - extracting fpdiv.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpdiv.asm &&
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 5 Oct 87   Version 2.0
X;
Xfpdiv   ident   2,0
X;
X; MOTOROLA DSP56000/1 FPLIB VERSION 2
X;
X; FPDIV - FLOATING POINT DIVIDE SUBROUTINE
X;
X; Entry points: fdiv_xa R = A / X
X;               fdiv_xy R = Y / X
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X   x1 = ma  (normalized)
X;       x0 = ea
X;
X;   Y   y1 = my  (normalized)
X;       y0 = ey
X;
X;   A   a2 = sign extension of ma
X;       a1 = ma  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of ea (always zero)
X;       b1 = ea
X;       b0 = zero
X;
X; Output variables:
X;
X;   R   a2 = sign extension of mr
X;       a1 = mr  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of er (always zero)
X;       b1 = er
X;       b0 = zero
X;
X; Error conditions:     Set CCR L=1 if divide by zero error.  Result is
X;                       set to the maximum floating point value having
X;                       the same sign as the dividend if the dividend
X;                       is non-zero.  Result is set to floating point
X;                       zero if the dividend is zero.  The CCR L bit
X;                       remains set until cleared by the user.
X;
X;                       Set CCR L=1 if floating point overflow.  Result
X;                       is set to the maximum floating point value of the
X;                       correct sign.  The CCR L bit remains set until
X;                       cleared by the user.
X;
X;                       Set CCR L=1 if floating point underflow.  Result
X;                       is set to floating point zero.  The CCR L bit
X;                       remains set until cleared by the user.
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;       y1                      x0
X;
X; Alters Address Registers
X;       r0
X;
X; Alters Program Control Registers
X;       pc      sr               
X;
X; Uses 0 locations on System Stack
X;
X;
Xfdiv_xy tfr     y0,b    y1,a            ;get ey, my
Xfdiv_xa sub     x0,b    fp_space:fp_ebias,x0 ;calculate er' = ea - ex,get ebias
X        add     x0,b                    ;add ebias to er'
X        tfr     x1,b    b,r0            ;get mx, save er'
X        tst     b                       ;check for divisor mx = 0
X        jne     _div1                   ;jump if divisor not zero
X        tst     a                       ;check for dividend ma = 0
X        jne     limit                   ;jump if dividend not zero
X        or      #$40,ccr                ;set L=1 for divide by zero error
X_div1   asr     a       a,b             ;force fractional quotient, copy ma
X        jeq     done                    ;jump if dividend ma = 0 (underflow)
X        abs     a       (r0)+           ;make dividend positive, adjust er'
X        eor     x1,b                    ;calculate quotient sign
X        and     #$fe,ccr                ;clear carry (quotient sign bit)
X        rep     #24                     ;repeat for 24 bit quotient
X        div     x1,a                    ;generate one quotient bit
X        jpl     _qpos                   ;jump if positive quotient
X        neg     a                       ;negate mr' for negative quotient
X_qpos   move    a0,a                    ;get quotient mr'
X        tst     a                       ;normalize mr' 1 extra bit
X        norm    r0,a                    ;shift 1 bit and update exponent by 1
X        jmp     norm1                   ;normalize and check for errors
X
SHAR_EOF
$TOUCH -am 1126102991 fpdiv.asm &&
chmod 0644 fpdiv.asm ||
echo "restore of fpdiv.asm failed"
set `wc -c fpdiv.asm`;Wc_c=$1
if test "$Wc_c" != "3937"; then
	echo original size 3937, current size $Wc_c
fi
# ============= fpfix.asm ==============
echo "x - extracting fpfix.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpfix.asm &&
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 5 Oct 87   Version 2.0
X;
Xfpfix   ident   2,0
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; FPFIX - FLOATING POINT TO FIXED POINT CONVERSION SUBROUTINE
X;
X; Entry points: fix_a   D = fix(A)
X;               fix_x   D = fix(X)
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X;       data = 56 bit fixed point data in standard integer/fractional
X;              accumulator data representation.
X;
X; Input variables:
X;
X;   X   x1 = mx  (normalized)
X;       x0 = ex
X;
X;   A   a2 = sign extension of ma
X;       a1 = ma  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of ea (always zero)
X;       b1 = ea
X;       b0 = zero
X;
X; Output variables:
X;
X;   D    a = data
X;
X; Error conditions:     Set CCR L=1 if conversion overflow error.  That is,
X;                       the input value was larger than +/- 256 and could
X;                       not be represented in the standard 56 bit accumulator
X;                       format.  Result is the maximum 56 bit fixed point
X;                       value having the same sign as the floating point
X;                       mantissa.  The CCR L bit remains set until cleared
X;                       by the user.
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;               x0      y1
X;
X; Alters Address Registers
X;       r0
X;
X; Alters Program Control Registers
X;       pc      sr
X;
X; Uses 0 locations on System Stack
X;
X;
Xfix_x   tfr     x0,b    x1,a            ;get mx,ex
Xfix_a   tst     a       fp_space:fp_ebias,x0    ;check ma, get bias
X        jeq     done                    ;jump if ma = 0
X        sub     x0,b    #>8,x0          ;remove ea bias, get shift limit
X        jlt     _eneg                   ;jump if exponent < 0
X        jeq     done                    ;jump if exponent = 0
X;
X; exponent > 0
X;
X        cmp     x0,b                    ;check left shift limit
X        jgt     _ehigh                  ;jump if exponent > 8
X        rep     b                       ;shift left b bits
X        asl     a                       ;shift data left
X        rts
X_ehigh  or      #$40,ccr                ;set L=1 for conversion overflow
X        tst     a                       ;check sign of ma
X        jpl     _fix1                   ;jump if ma positive
X        clr     a                       ;limit to maximum negative 56 bit value
X        move    #$80,a2                 ;set extension word
X        rts
X_fix1   clr     a                       ;limit to maximum positive 56 bit value
X        not     a                       ;set most significant word
X        move    a1,a0                   ;set least significant word
X        move    #$7f,a2                 ;set extension word
X        rts
X;
X; exponent < 0
X;
X_eneg   abs     b       #>24,x0         ;fix exponent, get right shift limit
X        sub     x0,b    b1,r0           ;check for underflow, save exponent
X        jge     _elow                   ;jump if fixed point underflow
X        move    fp_space:(r0+n0),x0     a,y1    ;lookup shift factor, get ma
X        mpy     -y1,x0,a                ;denormalize ma
X        rts
X_elow   jeq     _shift                  ;jump if exponent = -24
X        cmp     x0,b    b1,r0           ;check for underflow, save exponent
X        jge     zero                    ;jump if data underflow
X        move    fp_space:(r0+n0),x0     a,y1    ;lookup shift factor, get ma
X        mpy     -y1,x0,a                ;denormalize ma
X_shift  tfr     a,b     a2,a            ;shift down 24 bits more
X        move    b1,a0
X        rts
X
SHAR_EOF
$TOUCH -am 1126102991 fpfix.asm &&
chmod 0644 fpfix.asm ||
echo "restore of fpfix.asm failed"
set `wc -c fpfix.asm`;Wc_c=$1
if test "$Wc_c" != "4061"; then
	echo original size 4061, current size $Wc_c
fi
# ============= fpfloat.asm ==============
echo "x - extracting fpfloat.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpfloat.asm &&
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 6 Oct 87   Version 2.0
X;
Xfpfloat ident   2,0
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; FPFLOAT - FIXED POINT TO FLOATING POINT CONVERSION SUBROUTINE
X;
X; Entry points: float_a R = float(A)
X;               float_x R = float(X)
X;
X;       data = 56 bit two's complement fixed point number
X;              consisting of a 48 bit fraction with an 8 bit
X;              integer extension in standard accumulator data
X;              representation.
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X   x1 = data
X;
X;   A    a = data
X;
X; Output variables:
X;
X;   R   a2 = sign extension of mr
X;       a1 = mr  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of er (always zero)
X;       b1 = er
X;       b0 = zero
X;
X; Error conditions:     none
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;       y1
X;
X; Alters Address Registers
X;       r0
X;
X; Alters Program Control Registers
X;       pc      sr
X;
X; Uses 0 locations on System Stack
X;
X;
Xfloat_x tfr     x1,a                    ;get data
Xfloat_a tst     a       fp_space:fp_ebias,r0    ;check data, initialize er
X        jnr     float1                  ;jump if data normalized
Xnorm8   rep     #8                      ;normalize up to 8 bits left or right
X        norm    r0,a                    ;normalize one bit, update er
X        jnn     norm8                   ;jump if not normalized
Xfloat1  rnd     a                       ;round mr to 24 bits
X        norm    r0,a                    ;correct overflow due to rounding
X        jmp     check1                  ;go check exponent range
X
SHAR_EOF
$TOUCH -am 1126102991 fpfloat.asm &&
chmod 0644 fpfloat.asm ||
echo "restore of fpfloat.asm failed"
set `wc -c fpfloat.asm`;Wc_c=$1
if test "$Wc_c" != "2123"; then
	echo original size 2123, current size $Wc_c
fi
# ============= fpfloor.asm ==============
echo "x - extracting fpfloor.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpfloor.asm &&
Xfpfloor	ident	2,0
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; FPFLOOR - FLOATING POINT FLOOR SUBROUTINE
X;
X; Entry points:	floor_a	   R = floor(A)
X;		floor_x	   R = floor(X)
X;
X;	m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;	e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X	x1 = mx  (normalized)
X;	x0 = ex
X;
X;   A	a2 = sign extension of ma
X;	a1 = ma  (normalized)
X;	a0 = zero
X;
X;	b2 = sign extension of ea (always zero)
X;	b1 = ea
X;	b0 = zero
X;
X; Output variables:
X;
X;   R	a2 = sign extension of mr
X;	a1 = mr  (normalized)
X;	a0 = zero
X;
X;	b2 = sign extension of er (always zero)
X;	b1 = er
X;	b0 = zero
X;
X; Error conditions:	No error conditions are signaled.
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;	a2	a1	a0	a
X;	b2	b1	b0	b
X;	x1	x0
X;
X; Alters Address Registers
X;	r0
X;
X; Alters Program Control Registers
X;	pc	sr
X;	ssh	ssl	sp
X;
X; Uses 0 locations on System Stack
X;
X; Author - Brett Lindsley
X; Version - 2.0
X; Latest Revision - February 22, 1988
X;
Xfloor_x	tfr	x0,b	x1,a		;get mx,ex
Xfloor_a
X	tst	a	#$1fff+23,x0	;check a, max exponent w/o fraction
X	jeq	_done			;if a=0, result=0
X	cmp	x0,b	fp_space:fp_ebias,x0	;check for max input
X	jge	_done			;if max, result=input
X	cmp	x0,b	b,x1		;check for fraction, save exponent
X	jgt	_inrange		;jump if not less than one
X	clr	a	#0,b		;if less than one, result=0
X	jmp	_done
X_inrange
X	sub	x0,b	#>masktbl-1,x0	;subtract bias, point to mask table
X	add	x0,b			;point to mask
X	move	b1,r0			;put in address reg
X	move	x1,b			;restore exponent
X	move	p:(r0),x0		;get mask
X	and	x0,a			;round fraction to negative infinity
X_done
X	rts
Xmasktbl
X	dc	$c00000,$e00000,$f00000
X	dc	$f80000,$fc0000,$fe0000,$ff0000
X	dc	$ff8000,$ffc000,$ffe000,$fff000
X	dc	$fff800,$fffc00,$fffe00,$ffff00
X	dc	$ffff80,$ffffc0,$ffffe0,$fffff0
X	dc	$fffff8,$fffffc,$fffffe
X
SHAR_EOF
$TOUCH -am 1126102991 fpfloor.asm &&
chmod 0644 fpfloor.asm ||
echo "restore of fpfloor.asm failed"
set `wc -c fpfloor.asm`;Wc_c=$1
if test "$Wc_c" != "2009"; then
	echo original size 2009, current size $Wc_c
fi
# ============= fpfrac.asm ==============
echo "x - extracting fpfrac.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpfrac.asm &&
Xfpfrac  ident   2,0
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; This program, originally available on the Motorola DSP bulletin board,
X; is provided under a DISCLAIMER OF WARRANTY available from Motorola DSP
X; Operation, 6501 William Cannon Drive, West, Austin, Texas  78735-8598.
X;
X; FPFRAC - FLOATING POINT FRACTION SUBROUTINE
X;
X; Entry points: frac_a     R = frac(A)
X;               frac_x     R = frac(X)
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X   x1 = mx  (normalized)
X;       x0 = ex
X;
X;   A   a2 = sign extension of ma
X;       a1 = ma  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of ea (always zero)
X;       b1 = ea
X;       b0 = zero
X;                   
X; Output variables:
X;
X;   R   a2 = sign extension of mr
X;       a1 = mr  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of er (always zero)
X;       b1 = er
X;       b0 = zero
X;
X; Error conditions:     No error conditions are signaled.
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;       x1      x0      y1      y0
X;
X; Alters Address Registers
X;       r0
X;
X; Alters Program Control Registers
X;       pc      sr
X;       ssh     ssl     sp
X;
X; Uses 1 location on System Stack
X;
X; Version - 2.0
X; Latest Revision - February 22, 1988
X;
Xfrac_x
X        tfr     x0,b    x1,a            ;get mx,ex
Xfrac_a  
X        move    b1,y0                   ;copy input
X        move    a1,y1
X        jsr     floor_a                 ;get floor of input
X        move    b1,x0                   ;put floor in X
X        move    a1,x1
X        jmp     fsub_xy                 ;R=x-floor(x)
X 
X 
X 
X 
X
SHAR_EOF
$TOUCH -am 1126102991 fpfrac.asm &&
chmod 0644 fpfrac.asm ||
echo "restore of fpfrac.asm failed"
set `wc -c fpfrac.asm`;Wc_c=$1
if test "$Wc_c" != "1938"; then
	echo original size 1938, current size $Wc_c
fi
# ============= fpinit.asm ==============
echo "x - extracting fpinit.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpinit.asm &&
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 5 Oct 87   Version 2.0
X;
Xfpinit  ident   2,0
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; FPINIT - FLOATING POINT LIBRARY INITIALIZATION SUBROUTINE
X;
X; Entry point:  fpinit  Initialize address pointers and shift constant
X;                       table for DSP56000/1 floating point subroutine
X;                       library.
X;
X; Input variables:      none
X;
X; Output variables:
X;
X;       n0 = base address of shift constant table
X;       m0 = $ffff  (linear address modifier)
X;
X;       shift constant table - stores multiplication constants for
X;                              denormalization operations.
X;
X;       The X or Y data memory space (without the colon) used for the
X;       shift constant table must be specified in single quotes by a
X;       DEFINE directive for the global symbol "fp_space" and the base
X;       address of the shift constant table must be specified for the
X;       global symbol "fp_temp" via an EQU or similar directive.  An
X;       example is given below.
X;
X;               define  fp_space        'x'
X;       fp_temp equ     $0000
X;
X; Error conditions:     none
X;
X; Memory requirements:  28 locations in "fp_space" memory space
X;
X; Alters Address Registers
X;               n0      m0
X;
X; Alters Program Control Registers
X;       pc      sr
X;
X; Uses 0 locations on System Stack
X;
X;
X        org     fp_space:fp_temp
X        ds      4       ;temporary storage locations
Xfp_23   dc      23      ;exponent delta limit
Xfp_ebias dc     $001fff ;fixed point exponent bias
Xfp_emax dc      $003fff ;maximum exponent
Xfp_shift dc     $800000,$c00000,$e00000,$f00000,$f80000,$fc0000,$fe0000,$ff0000
X        dc      $ff8000,$ffc000,$ffe000,$fff000,$fff800,$fffc00,$fffe00,$ffff00
X        dc      $ffff80,$ffffc0,$ffffe0,$fffff0,$fffff8,$fffffc,$fffffe
Xfp_m1   dc      $ffffff
X;
X        org p:
Xfpinit  move    fp_space:fp_m1,m0       ;initialize linear address modifier
X        move    #fp_shift,n0    ;initialize base address of shift constant table
X        and     #$f3,mr         ;reset scaling modes (S1,S0)
X        and     #$bf,ccr        ;reset overflow flag (L bit)
X        rts
X
SHAR_EOF
$TOUCH -am 1126102991 fpinit.asm &&
chmod 0644 fpinit.asm ||
echo "restore of fpinit.asm failed"
set `wc -c fpinit.asm`;Wc_c=$1
if test "$Wc_c" != "2396"; then
	echo original size 2396, current size $Wc_c
fi
# ============= fplist.asm ==============
echo "x - extracting fplist.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fplist.asm &&
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 5 Oct 87   Version 2.0
X;
X;
X; Call FPLIB subroutines for listing purposes
X;
X        page    132,60,5,5
X        opt     nomd,mex,mu,cre
X        define  fp_space 'x'
Xfp_temp equ     0
X        org     p:0
X        jmp     start
X        org     p:$100
X        page
X        include 'fpinit'
X        page
X        include 'fpadd'
X        page
X        include 'fpsub'
X        page
X        include 'fpcmp'
X        page
X        include 'fpmpy'
X        page
X        include 'fpmac'
X        page
X        include 'fpdiv'
X        page
X        include 'fpsqrt'
X        page
X        include 'fpneg'
X        page
X        include 'fpabs'
X        page
X        include 'fpscale'
X        page
X        include 'fpfix'
X        page
X        include 'fpfloat'
X        page
Xstart   jsr     fpinit
Xloop    jsr     fadd_xa
X        jsr     fadd_xy
X        jsr     fsub_xa
X        jsr     fsub_xy
X        jsr     fcmp_xa
X        jsr     fcmp_xy
X        jsr     fmpy_xa
X        jsr     fmpy_xy
X        jsr     fmac_xya
X        jsr     fmac_mxya
X        jsr     fdiv_xa
X        jsr     fdiv_xy
X        jsr     fsqrt_a
X        jsr     fsqrt_x
X        jsr     fneg_a
X        jsr     fneg_x
X        jsr     fabs_a
X        jsr     fabs_x
X        jsr     fscal_xa
X        jsr     fscal_xy
X        jsr     fix_a
X        jsr     fix_x
X        jsr     float_a
X        jsr     float_x
X        jmp     loop
X        end
X
SHAR_EOF
$TOUCH -am 1126102991 fplist.asm &&
chmod 0644 fplist.asm ||
echo "restore of fplist.asm failed"
set `wc -c fplist.asm`;Wc_c=$1
if test "$Wc_c" != "1673"; then
	echo original size 1673, current size $Wc_c
fi
# ============= fpmac.asm ==============
echo "x - extracting fpmac.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpmac.asm &&
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 30 Oct 87   Version 2.1
X;
Xfpmac   ident   2,1
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; FPMAC - FLOATING POINT MULTIPLY/ACCUMULATION SUBROUTINE
X;
X; Entry points: fmac_xya        R = A + X * Y
X;               fmac_mxya       R = A - X * Y
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X   x1 = mx  (normalized)
X;       x0 = ex
X;
X;   Y   y1 = my  (normalized)
X;       y0 = ey
X;
X;   A   a2 = sign extension of ma
X;       a1 = ma  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of ea (always zero)
X;       b1 = ea
X;       b0 = zero
X;
X; Output variables:
X;
X;   R   a2 = sign extension of mr
X;       a1 = mr  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of er (always zero)
X;       b1 = er
X;       b0 = zero
X;
X; Error conditions:     Set CCR L=1 if floating point overflow.  Result
X;                       is set to the maximum floating point value of the
X;                       correct sign.  The CCR L bit remains set until
X;                       cleared by the user.
X;
X;                       Set CCR L=1 if floating point underflow.  Result
X;                       is set to floating point zero.  The CCR L bit
X;                       remains set until cleared by the user.
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;       x1      x0      y1      y0
X;
X; Alters Address Registers
X;       r0
X;
X; Alters Program Control Registers
X;       pc      sr
X;
X; Uses 1 location on System Stack
X;
Xfmac_xya move   a,fp_space:fp_temp+1    ;save ma
X        move    b,fp_space:fp_temp+2    ;save ea
X        jsr     fmpy_xy                 ;multiply x*y first
X        move    fp_space:fp_temp+1,x1   ;restore ma
X        move    fp_space:fp_temp+2,x0   ;restore ea
X        jmp     fadd_xa                 ;add product to a
X;
Xfmac_mxya move  a,fp_space:fp_temp+1    ;save ma
X        move    b,fp_space:fp_temp+2    ;save ea
X        jsr     fmpy_xy                 ;multiply x*y first
X        move    a,x1                    ;save product mantissa
X        move    b,x0                    ;save product exponent
X        move    fp_space:fp_temp+1,a    ;restore ma
X        move    fp_space:fp_temp+2,b    ;restore ea
X        jmp     fsub_xa                 ;subtract product from a
X
X
SHAR_EOF
$TOUCH -am 1126102991 fpmac.asm &&
chmod 0644 fpmac.asm ||
echo "restore of fpmac.asm failed"
set `wc -c fpmac.asm`;Wc_c=$1
if test "$Wc_c" != "2800"; then
	echo original size 2800, current size $Wc_c
fi
# ============= fpmpy.asm ==============
echo "x - extracting fpmpy.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpmpy.asm &&
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 5 Oct 87   Version 2.0
X;
Xfpmpy   ident   2,0
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; FPMPY - FLOATING POINT MULTIPLICATION SUBROUTINE
X;
X; Entry points: fmpy_xy R = X * Y
X;               fmpy_xa R = X * A
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X   x1 = mx  (normalized)
X;       x0 = ex
X;
X;   Y   y1 = my  (normalized)
X;       y0 = ey
X;
X;   A   a2 = sign extension of ma
X;       a1 = ma  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of ea (always zero)
X;       b1 = ea
X;       b0 = zero
X;
X; Output variables:
X;
X;   R   a2 = sign extension of mr
X;       a1 = mr  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of er (always zero)
X;       b1 = er
X;       b0 = zero
X;
X; Error conditions:     Set CCR L=1 if floating point overflow.  Result
X;                       is set to the maximum floating point value of the
X;                       correct sign.  The CCR L bit remains set until
X;                       cleared by the user.
X;
X;                       Set CCR L=1 if floating point underflow.  Result
X;                       is set to floating point zero.  The CCR L bit
X;                       remains set until cleared by the user.
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;                                       
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;       y1
X;
X; Alters Address Registers
X;       r0
X;
X; Alters Program Control Registers
X;       pc      sr
X;
X; Uses 0 locations on System Stack
X;
X;
Xfmpy_xy tfr     y0,b    y1,a            ;get ey, my
Xfmpy_xa add     x0,b    fp_space:fp_ebias,x0    ;er' = ex + ea,get ebias
X        sub     x0,b    a,y1            ;subtract ebias from er',get ma
X        mpy     x1,y1,a         b,r0    ;mr = mx * ma, get er'
X        jmp     norm1                   ;normalize and check result
X
SHAR_EOF
$TOUCH -am 1126102991 fpmpy.asm &&
chmod 0644 fpmpy.asm ||
echo "restore of fpmpy.asm failed"
set `wc -c fpmpy.asm`;Wc_c=$1
if test "$Wc_c" != "2328"; then
	echo original size 2328, current size $Wc_c
fi
# ============= fpneg.asm ==============
echo "x - extracting fpneg.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpneg.asm &&
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 5 Oct 87   Version 2.0
X;
Xfpneg   ident   2,0
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; FPNEG - FLOATING POINT NEGATION SUBROUTINE
X;
X; Entry points: fneg_a  R = -A
X;               fneg_x  R = -X
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X   x1 = mx  (normalized)
X;       x0 = ex
X;
X;   A   a2 = sign extension of ma
X;       a1 = ma  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of ea (always zero)
X;       b1 = ea
X;       b0 = zero
X;
X; Output variables:
X;
X;   R   a2 = sign extension of mr
X;       a1 = mr  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of er (always zero)
X;       b1 = er
X;       b0 = zero
X;
X; Error conditions:     Set CCR L=1 if floating point overflow.  Result
X;                       is set to the maximum floating point value of the
X;                       correct sign.  The CCR L bit remains set until
X;                       cleared by the user.
X;
X;                       Set CCR L=1 if floating point underflow.  Result
X;                       is set to floating point zero.  The CCR L bit
X;                       remains set until cleared by the user.
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;       x1      x0      y1      y0
X;
X; Alters Address Registers
X;       r0
X;
X; Alters Program Control Registers
X;       pc      sr
X;
X; Uses 0 locations on System Stack
X;
X;
Xfneg_x  tfr     x0,b    x1,a            ;get ex, mx
Xfneg_a  neg     a       b,r0            ;negate ma, save ea
X        jmp     norm1                   ;normalize ma and check ea
X
SHAR_EOF
$TOUCH -am 1126103091 fpneg.asm &&
chmod 0644 fpneg.asm ||
echo "restore of fpneg.asm failed"
set `wc -c fpneg.asm`;Wc_c=$1
if test "$Wc_c" != "2099"; then
	echo original size 2099, current size $Wc_c
fi
# ============= fpscale.asm ==============
echo "x - extracting fpscale.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpscale.asm &&
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 5 Oct 87   Version 2.0
X;
Xfpscale ident   2,0
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; FPSCALE - FLOATING POINT SCALING SUBROUTINE
X;
X; Entry points: fscal_xa        R = A * 2**X
X;               fscal_xy        R = Y * 2**X
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X   x0 = ex
X;
X;   Y   y1 = my  (normalized)
X;       y0 = ey
X;
X;   A   a2 = sign extension of ma
X;       a1 = ma  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of ea (always zero)
X;       b1 = ea
X;       b0 = zero
X;
X; Output variables:
X;
X;   R   a2 = sign extension of mr
X;       a1 = mr  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of er (always zero)
X;       b1 = er
X;       b0 = zero
X;
X; Error conditions:     Set CCR L=1 if floating point overflow.  Result
X;                       is set to the maximum floating point value of the
X;                       correct sign.  The CCR L bit remains set until
X;                       cleared by the user.
X;
X;                       Set CCR L=1 if floating point underflow.  Result
X;                       is set to floating point zero.  The CCR L bit
X;                       remains set until cleared by the user.
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;       x1      x0      y1      y0
X;
X; Alters Address Registers
X;       r0
X;
X; Alters Program Control Registers
X;       pc      sr
X;
X; Uses 0 locations on System Stack
X;
X;
Xfscal_xy        tfr     y0,b    y1,a    ;get ey, my
Xfscal_xa        add     x0,b            ;add scale factor to ea
X        move    b,r0                    ;save er'
X        jmp     check                   ;check for exponent errors
X
SHAR_EOF
$TOUCH -am 1126103091 fpscale.asm &&
chmod 0644 fpscale.asm ||
echo "restore of fpscale.asm failed"
set `wc -c fpscale.asm`;Wc_c=$1
if test "$Wc_c" != "2203"; then
	echo original size 2203, current size $Wc_c
fi
# ============= fpsqrt.asm ==============
echo "x - extracting fpsqrt.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpsqrt.asm &&
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 5 Oct 87   Version 2.0
X;
Xfpsqrt  ident   2,0
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; FPSQRT - FLOATING POINT SQUARE ROOT SUBROUTINE
X;
X; Entry points: fsqrt_a R = square root(A)
X;               fsqrt_x R = square root(X)
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X   x1 = mx  (normalized)
X;       x0 = ex
X;
X;   A   a2 = sign extension of ma
X;       a1 = ma  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of ea (always zero)
X;       b1 = ea
X;       b0 = zero
X;
X; Output variables:
X;
X;   R   a2 = sign extension of mr
X;       a1 = mr  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of er (always zero)
X;       b1 = er
X;       b0 = zero
X;
X; Error conditions:     Set CCR L=1 if input value is negative.  Result
X;                       is set to floating point zero.  The CCR L bit
X;                       remains set until cleared by the user.
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;       x1      x0      y1      y0
X;
X; Alters Address Registers
X;       r0
X;
X; Alters Program Control Registers
X;       pc      sr
X;       la      lc
X;       ssh     ssl     sp
X;
X; Uses 2 locations on System Stack
X;
X;
Xfsqrt_x tfr     x0,b    x1,a            ;get mx,ex
Xfsqrt_a tst     a       fp_space:fp_ebias,x0    ;check for negative input
X        jmi     under                   ;jump if negative, set L bit
X        jeq     done                    ;jump if zero
X        sub     x0,b                    ;remove ebias from ea
X        lsr     b       #<$40,y0        ;er' = ea / 2, get first guess
X        jcc     _sqrt1                  ;jump if er' even
X        asr     a       fp_space:fp_m1,x1       ;divide ma by 2, get -1
X        sub     x1,b                    ;increment er' by 1
X_sqrt1  add     x0,b    y0,x0           ;add ebias to er', save first temp
X        clr     b       b,r0            ;clear root, save er'
X        do      #23,_sqrt2              ;square all 23 bits
X        mac     -x0,x0,a        a,x1    ;square temp, save ma
X        tge     x0,b                    ;update root if correct guess
X        move    y0,a                    ;get guess bit
X        asr     a                       ;try next bit
X        add     b,a     a,y0            ;form root guess, save guess bit
X        tfr     x1,a    a,x0            ;get ma, save temp
X_sqrt2
X        tfr     b,a     r0,b            ;get root mr, er
X        rts
X
SHAR_EOF
$TOUCH -am 1126103091 fpsqrt.asm &&
chmod 0644 fpsqrt.asm ||
echo "restore of fpsqrt.asm failed"
set `wc -c fpsqrt.asm`;Wc_c=$1
if test "$Wc_c" != "2961"; then
	echo original size 2961, current size $Wc_c
fi
# ============= fpsub.asm ==============
echo "x - extracting fpsub.asm (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpsub.asm &&
X
X;
X; This program originally available on the Motorola DSP bulletin board.
X; It is provided under a DISCLAIMER OF WARRANTY available from
X; Motorola DSP Operation, 6501 Wm. Cannon Drive W., Austin, Tx., 78735.
X; 
X; Last Update 15 Oct 87   Version 2.1
X;
Xfpsub   ident   2,1
X;
X; MOTOROLA DSP56000/1 FPLIB - VERSION 2
X;
X; FPSUB - FLOATING POINT SUBTRACTION SUBROUTINE
X;
X; Entry points: fsub_xa R = A - X
X;               fsub_xy R = Y - X
X;
X;       m = 24 bit mantissa (two's complement, normalized fraction)
X;
X;       e = 14 bit exponent (unsigned integer, biased by +8191)
X;
X; Input variables:
X;
X;   X   x1 = mx  (normalized)
X;       x0 = ex
X;
X;   Y   y1 = my  (normalized)
X;       y0 = ey
X;
X;   A   a2 = sign extension of ma
X;       a1 = ma  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of ea (always zero)
X;       b1 = ea
X;       b0 = zero
X;
X; Output variables:
X;
X;   R   a2 = sign extension of mr
X;       a1 = mr  (normalized)
X;       a0 = zero
X;
X;       b2 = sign extension of er (always zero)
X;       b1 = er
X;       b0 = zero
X;
X; Error conditions:     Set CCR L=1 if floating point overflow.  Result
X;                       is set to the maximum floating point value of the
X;                       correct sign.  The CCR L bit remains set until
X;                       cleared by the user.
X;
X;                       Set CCR L=1 if floating point underflow.  Result
X;                       is set to floating point zero.  The CCR L bit
X;                       remains set until cleared by the user.
X;
X; Assumes n0, m0, shift constant table and scaling modes
X; initialized by previous call to the subroutine "fpinit".
X;
X; Alters Data ALU Registers
X;       a2      a1      a0      a
X;       b2      b1      b0      b
X;       x1      x0      y1      y0
X;
X; Alters Address Registers
X;       r0
X;
X; Alters Program Control Registers
X;       pc      sr                                                  
X;
X; Uses 0 locations on System Stack
X;
X;
Xfsub_xy tfr     y0,b    y1,a            ;get ey, my
Xfsub_xa sub     x0,b    b1,y1           ;compare delta = ea - ex, save ea
X        jge     _dpos                   ;jump if ea >= ex
X;
X; ea < ex
X;
X_dneg   tfr     x1,a    a1,x1           ;swap ma with mx
X        neg     a       x0,y1           ;negate mx, save ex
X        abs     b       fp_space:fp_23,y0       ;negate er', get delta limit
X        cmp     y0,b    b1,r0           ;check delta limit, save delta
X        jle     addm                    ;jump if delta =< 23
X        tst     a       x0,r0           ;get er', setup CCR for norm
X        jmp     norm1                   ;normalize result
X;
X; ea >= ex
X;
X_dpos   move            fp_space:fp_23,y0       ;get delta limit
X        cmp     y0,b    b1,r0           ;check delta limit, save delta
X        jgt     done1                   ;jump if delta > 23
X        move    fp_space:(r0+n0),x0     ;lookup shift constant s
X        mac     x1,x0,a y1,r0           ;denormalize by s, 
X                                        ;  subtract mantissa, get er'
X        jmp     norm                    ;normalize result
X
X
SHAR_EOF
$TOUCH -am 1126103091 fpsub.asm &&
chmod 0644 fpsub.asm ||
echo "restore of fpsub.asm failed"
set `wc -c fpsub.asm`;Wc_c=$1
if test "$Wc_c" != "3170"; then
	echo original size 3170, current size $Wc_c
fi
# ============= durbin.hlp ==============
echo "x - extracting durbin.hlp (Text)"
sed 's/^X//' << 'SHAR_EOF' > durbin.hlp &&
X2 DURBIN
X 
X         Name: DURBIN
X         Type: Assembler Program
X      Version: 1.0
X Date Entered: 10-Nov-87
X  Last Change: 10-Nov-87
X 
X Description: Durbin Solution for LPC Coefficients in Floating Point
X 
X This program uses the the DURBIN algorithm to find a set of
X linear predictive coefficients (LPC) given an autocorrelation
X vector.  This program uses the floating point library (FPLIB)
X to perform the calculations.  LPC coefficients can be used in
X speech analysis/synthesis systems such as: vocoding, stochastic
X speech coding, multipulse speech coding, speech recognition, etc.
X 
X Approximate execution time for ten LPC coefficients on DURBIN
X using a 20.5 Mhz DSP56000/1 is 855  microseconds.
X 
X Since the description of the DURBIN algorithm is beyond the scope
X of this help file, only the method of coding the algorithm from
X a FORTRAN program is given.  A complete description of the DURBIN
X algorithm is given in ref. 1 and a FORTRAN program is shown below:
X 
X       DIMENSION R(0:10),ALPHA(10)
X       DOUBLE PRECISION Q
X       DATA R/1.0,.65,.6,.5,.1,.1,-.05,-.03,-.05,-.07,.01/
X       CALL DURBIN(R,ALPHA,10)
X       PRINT *,ALPHA
X       END
X C
X C      DURBINS RECURSIVE SOLUTION OF AR ESTIMATE
X C
X       SUBROUTINE DURBIN(RN,ALPHA,NCOEF)
X       DIMENSION RN(0:*),ALPHA(*),ANEW(100)
X       REAL K
X 
X       E=RN(0)
X       ALPHA(1)=RN(1)/E
X       E=(1.0-ALPHA(1)*ALPHA(1))*E
X       DO 1000 I=2,NCOEF
X       SUM=0
X       DO 10 J=1,I-1
X 10          SUM=SUM+ALPHA(J)*RN(I-J)
X       K=(RN(I)-SUM)/E
X       ALPHA(I)=K
X       DO 40 J=1,I-1
X 40          ANEW(J)=ALPHA(J)-K*ALPHA(I-J)
X       DO 70 J=1,I-1
X 70          ALPHA(J)=ANEW(J)
X       E=(1.0-K*K)*E
X 1000      CONTINUE
X       RETURN
X       END
X 
X The program can be slightly rearranged as shown below:
X 
X       DIMENSION R(0:10),ALPHA(10)
X       DOUBLE PRECISION Q
X       DATA R/1.0,.65,.6,.5,.1,.1,-.05,-.03,-.05,-.07,.01/
X       CALL DURBIN(R,ALPHA,10)
X       PRINT *,ALPHA
X       END
X C
X C      DURBINS RECURSIVE SOLUTION OF AR ESTIMATE
X C
X       SUBROUTINE DURBIN(RN,ALPHA,NCOEF)
X       DIMENSION RN(0:*),ALPHA(*),ANEW(100)
X       REAL K
X 
X       E=RN(0)
X       ALPHA(1)=RN(1)/E
X       E=(1.0-ALPHA(1)*ALPHA(1))*E
X 
X       I=2
X       M=1
X       DO 1000 IXX=1,NCOEF-1
X       SUM=0
X       IPTR=M
X       DO 10 J=1,M
X           SUM=SUM+ALPHA(J)*RN(IPTR)
X           IPTR=IPTR-1
X 10    CONTINUE
X       K=(RN(I)-SUM)/E
X       ALPHA(I)=K
X       IPTR=M
X       DO 40 J=1,M
X           ANEW(J)=ALPHA(J)-K*ALPHA(IPTR)
X           IPTR=IPTR-1
X 40    CONTINUE
X       DO 70 J=1,M
X 70          ALPHA(J)=ANEW(J)
X       E=(1.0-K*K)*E
X       I=I+1
X       M=M+1
X 1000  CONTINUE
X       RETURN
X       END
X 
X The second version is easier to implement on the DSP56000.
X The assembly program DURBIN.ASM is directly coded from the
X second FORTRAN program.
X 
X 
X References
X ----------
X 1.  "Digital Processing of Speech Signals", L.R. Rabiner,R.W.Schafer
X 
X 
X 
X 
X
SHAR_EOF
$TOUCH -am 1126102891 durbin.hlp &&
chmod 0644 durbin.hlp ||
echo "restore of durbin.hlp failed"
set `wc -c durbin.hlp`;Wc_c=$1
if test "$Wc_c" != "3017"; then
	echo original size 3017, current size $Wc_c
fi
# ============= fpcalls.hlp ==============
echo "x - extracting fpcalls.hlp (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpcalls.hlp &&
X2 FPCALLS
X 
X 
X FPLIB - MOTOROLA DSP56000/1 FLOATING POINT SOFTWARE SUBROUTINE LIBRARY
X 
X             CALLING CONVENTIONS - VERSION 2.0
X 
X Revision 1.0      August 29, 1986
X Revision 1.1      March  25, 1987
X Revision 2.0      October 5, 1987
X 
X MOTOROLA, INC.
X COPYRIGHT 1986, 1987
X ALL RIGHTS RESERVED
X 
X INTRODUCTION
X 
X FPLIB is a useful set of floating point arithmetic subroutines for the
X Motorola DSP56000/1 digital signal processor.  This HELP file defines
X the subroutine calling conventions and condition codes used by the
X DSP56000/1 floating point software subroutine library (FPLIB).
X Register usage and error conditions are described.  The storage format
X and arithmetic representation are not discussed here but are given in
X the FPDEF.HLP file. 
X 
X FPLIB INITIALIZATION AND ASSUMPTIONS
X 
X FPLIB must be initialized by calling the subroutine "FPINIT" before
X any other FPLIB subroutines are used.  FPLIB assumes that R0, N0 and
X M0 are RESERVED pointers for FPLIB and should not be used by the
X calling program. FPLIB also assumes that the scaling modes are
X DISABLED (NO SCALING) and that the CCR limit (L) bit is cleared so
X that FPLIB subroutines can set it to indicate error conditions.  These
X assumptions are initialized by the FPINIT subroutine.  FPINIT need
X only be called once per application program unless the above
X assumptions are violated.  However, FPINIT may be called at any time
X if the user needs to restore the FPLIB assumptions. No FPLIB state
X information (except the L bit error flag) is carried from one FPLIB
X subroutine to another.  A final caution is that FPINIT clears the CCR
X L bit so any previous error indication will be lost. 
X 
X FPLIB MEMORY USAGE
X 
X FPLIB uses approximately 32 words of data memory for storage of certain
X constants and tables.  The user may specify any address in X or Y data
X memory for this storage area.  This is done by specifying the memory
X space label "fp_space" with an assembler DEFINE directive and the memory
X base address label "fp_temp" with an assembler EQU directive as shown
X below.
X 
X       define      fp_space      'x'      ;FPLIB storage in X Data RAM
X fp_temp      equ      0                  ;beginning at address $0000
X 
X For code efficiency, fp_temp should be located in the bottom 64 locations
X of X or Y data memory to take advantage of the absolute short addressing
X mode.
X 
X The current version of FPLIB requires approximately 200 program memory
X locations if all subroutines are included.  Most subroutines require
X other subroutines to be included since many share common code.
X 
X FPLIB REGISTER USAGE
X 
X FPLIB uses all of the DSP56000/1 data ALU registers for input variables,
X output variables and temporary storage.  FPLIB does not preserve any
X data ALU registers so users should save/restore data ALU registers as
X required.  Input and output variables are described using a floating
X point register notation (shown in capital letters below) similar to the
X DSP56000/1 register names.  The floating point and fixed point register
X usage is indicated in lower case letters.  The floating point mantissa
X word is indicated with "m" and the floating point exponent word is
X indicated with "e".
X 
X Input variables:
X 
X    X      x1 = mx  (normalized)
X           x0 = ex
X 
X    Y      y1 = my  (normalized)
X           y0 = ey
X 
X    A      a2 = sign extension of ma
X           a1 = ma  (normalized)
X           a0 = zero
X 
X           b2 = sign extension of ea (always zero)
X           b1 = ea
X           b0 = zero
X 
X    D       a = fixed point data
X 
X Output variables:
X 
X    R      a2 = sign extension of mr
X           a1 = mr  (normalized)
X           a0 = zero
X 
X           b2 = sign extension of er (always zero)
X           b1 = er
X           b0 = zero
X 
X    D       a = fixed point data
X 
X FPLIB SUBROUTINE CALLS
X 
X FPLIB subroutines are called with a JScc, JSCLR, JSR or JSSET instruction.
X Input variables are loaded before calling the FPLIB subroutine and output
X variables are available after the FPLIB subroutine returns to the calling
X program.  Input variables may be destroyed by the subroutine.  In general,
X the condition codes are only valid after the floating point compare "fcmp"
X subroutine.
X 
X Entry Point      Operation
X -----------      ---------
X fpinit            Initialize FPLIB
X fadd_xa           R = A + X
X fadd_xy           R = Y + X
X fsub_xa           R = A - X
X fsub_xy           R = Y - X
X fcmp_xa           A - X, set condition codes
X fcmp_xy           Y - X, set condition codes
X fmpy_xa           R = A * X
X fmpy_xy           R = X * Y
X fmac_xya          R = A + X * Y
X fmac_mxya         R = A - X * Y
X fdiv_xa           R = A / X
X fdiv_xy           R = Y / X
X fscal_xa          R = A * 2**ex, assumes mx=1
X fscal_xy          R = Y * 2**ex, assumes mx=1
X fsqrt_a           R = square root (A)
X fsqrt_x           R = square root (X)
X fneg_a            R = - A
X fneg_x            R = - X
X fabs_a            R = absolute value (A)
X fabs_x            R = absolute value (X)
X fix_a             D = fixed point conversion (A)
X fix_x             D = fixed point conversion (X)
X float_a           R = floating point conversion (A)
X float_x           R = floating point conversion (X)
X floor_a           R = floor(A), largest integer less than or equal to A
X floor_x           R = floor(X)
X fceil_a           R = ceil(A), smallest integer greater than or equal to A
X fceil_x           R = ceil(X)
X frac_a            R = frac(A), fractional part of A
X frac_x            R = frac(X)
X                       
X 
X FPLIB ERROR CONDITIONS
X 
X The FPLIB subroutines detect various error conditions and set the CCR
X limit (L) bit as an error flag.  The user may test the CCR L bit upon
X return from the subroutine.  Note that the CCR L bit remains set until
X cleared by the user.  To promote real-time application, each
X subroutine also substitutes a floating point (or fixed point) value
X for the result.  This allows the real-time system to run continuously
X in the presence of errors which would typically abort a FORTRAN or C
X program.  These error conditions and result values are given for each
X subroutine below. 
X 
X Entry Point    Error Conditions            Result Value
X -----------    ----------------            ------------
X fpinit         none
X fcmp_xa      
X fcmp_xy
X float_a
X float_x
X floor_a
X floor_x
X fceil_a
X fceil_x
X frac_a
X frac_x
X 
X fadd_xa        floating point overflow     maximum value, correct sign.
X fadd_xy        floating point underflow    zero.
X fsub_xa
X fsub_xy            
X fmpy_xa
X fmpy_xy
X fmac_xya
X fmac_mxya
X fscal_xa
X fscal_xy
X fneg_a
X fneg_x
X fabs_a
X fabs_x
X 
X fdiv_xa        floating point overflow       maximum value, correct sign.
X fdiv_xy        floating point underflow      zero.
X                divide by zero                if dividend non-zero, maximum
X                                              value, correct sign.
X                                              if dividend zero, zero.
X 
X fsqrt_a        negative input value          zero.
X fsqrt_x
X 
X fix_a          fixed point overflow          maximum fixed point value,
X fix_x                                        correct sign.
X 
X FPLIB CONDITION CODES
X 
X In general, conditional jumps based on condition codes may be used
X only after calling the floating point compare subroutines (fcmp_xa and
X fcmp_xy).  The following branch conditions can be used after calling
X fcmp_xa or fcmp_xy. Other branch conditions should not be used. 
X 
X       "cc" Mnemonic                  Condition
X       -------------                  ---------
X       EQ - equal                      Z = 1
X       GE - greater than or equal      N eor V = 0
X       GT - greater than               Z + (N eor V) = 0
X       LE - less than or equal         Z + (N eor V) = 1
X       LT - less than                  N eor V = 1
X       NE - not equal                  Z = 0
X 
X FPLIB BUGS AND EXTENSIONS
X 
X FLPIB has been tested for a short time and is thought to be bug free.
X However, if bugs are found they should be reported to Motorola so they
X can be fixed.  Other subroutines may be added to extend FPLIB as time
X allows.  User-written FPLIB extensions should be submitted to Motorola
X for possible inclusion in FPLIB.
X  
X FPLIB EXECUTION TIMES
X 
X The FPLIB subroutines are generic floating point routines which
X include rounding, error detection (such as floating point overflow and
X underflow) and error correction (result substitution).  As such, their
X execution time is data dependent.  Of course, users who do not want
X these safety features may remove them (with some editing) to gain a
X modest speed improvement. The best case and worst case execution times
X are given below.  The average is somewhere in between and is data and
X algorithm dependent.  The cycle count is in DSP56000/1 INSTRUCTION
X CYCLES and the execution time assumes a 20.5 MHz clock with no wait
X states or external bus contention.  The calling program subroutine
X call is not included in these times since it can take various forms
X but the FPLIB return from subroutine (RTS) execution time is included.
X 
X Entry Point      Best Case Execution Time      Worst Case Execution Time
X -----------      ------------------------      -------------------------
X fpinit            6 cycles, 0.59 usec           6 cycles,  0.59 usec
X fadd_xa          12 cycles, 1.17 usec          75 cycles,  7.32 usec
X fadd_xy          13 cycles, 1.27 usec          76 cycles,  7.41 usec
X fsub_xa          11 cycles, 1.07 usec          71 cycles,  6.93 usec
X fsub_xy          12 cycles, 1.17 usec          72 cycles,  7.02 usec
X fcmp_xa           7 cycles, 0.68 usec          14 cycles,  1.37 usec
X fcmp_xy           8 cycles, 0.78 usec          15 cycles,  1.46 usec
X fmpy_xa          18 cycles, 1.76 usec          63 cycles,  6.15 usec
X fmpy_xy          19 cycles, 1.85 usec          64 cycles,  6.24 usec
X fmac_xya         39 cycles, 3.80 usec         147 cycles, 14.34 usec
X fmac_mxya        40 cycles, 3.90 usec         145 cycles, 14.15 usec
X fdiv_xa          12 cycles, 1.17 usec         109 cycles, 10.63 usec
X fdiv_xy          13 cycles, 1.27 usec         110 cycles, 10.73 usec
X fscal_xa         12 cycles, 1.17 usec          15 cycles,  1.46 usec
X fscal_xy         13 cycles, 1.27 uses          16 cycles,  1.56 usec
X fsqrt_a           7 cycles, 0.68 usec         158 cycles, 15.41 usec
X fsqrt_x           8 cycles, 0.78 usec         159 cycles, 15.51 usec
X fneg_a           16 cycles, 1.56 usec          61 cycles,  5.95 usec
X fneg_x           17 cycles, 1.66 usec          62 cycles,  6.05 usec
X fabs_a            5 cycles, 0.49 usec          64 cycles,  6.24 usec
X fabs_x            6 cycles, 0.59 usec          65 cycles,  6.34 usec
X fix_a             5 cycles, 0.49 usec          27 cycles,  2.63 usec
X fix_x             6 cycles, 0.59 usec          28 cycles,  2.73 usec
X float_a          11 cycles, 1.07 usec          83 cycles,  8.10 usec
X float_x          12 cycles, 1.17 usec          84 cycles,  8.20 usec
X floor_a           5 cycles, 0.49 usec          18 cycles,  1.76 usec
X floor_x           6 cycles, 0.59 usec          19 cycles,  1.85 usec
X fceil_a           9 cycles, 0.88 usec          22 cycles,  2.15 usec
X fceil_x          10 cycles, 0.98 usec          23 cycles,  2.24 usec
X frac_a           25 cycles, 2.44 usec          98 cycles,  9.56 usec
X frac_x           26 cycles, 2.54 usec          99 cycles,  9.66 usec
X 
X CONCLUSION
X 
X FPLIB is a compact, software floating library which can be used in
X real-time applications.  It can be used selectively to extend the
X dynamic range of the DSP56000/1 fixed point fractional arithmetic or
X as a basic data type to support high level languages.  The worst case
X performance is roughly equivalent to a 12.5 MHz MC68881 floating point
X coprocessor.  The average performance is believed to be about twice as
X fast as the worst case performance. 
X 
X 
X 
X 
X 
X 
X 
X
SHAR_EOF
$TOUCH -am 1126102891 fpcalls.hlp &&
chmod 0644 fpcalls.hlp ||
echo "restore of fpcalls.hlp failed"
set `wc -c fpcalls.hlp`;Wc_c=$1
if test "$Wc_c" != "12166"; then
	echo original size 12166, current size $Wc_c
fi
# ============= fpdef.hlp ==============
echo "x - extracting fpdef.hlp (Text)"
sed 's/^X//' << 'SHAR_EOF' > fpdef.hlp &&
X
XFPLIB - MOTOROLA DSP56000/1 FLOATING POINT SOFTWARE SUBROUTINE LIBRARY
X
X                FORMAT DEFINITION - VERSION 2.0
X
XRevision 1.0    August 29, 1986
XRevision 1.1    March  25, 1987
XRevision 2.0    October 5, 1987
X
XINTRODUCTION
X
XFPLIB is a useful set of floating point arithmetic subroutines for the
XMotorola DSP56000/1 digital signal processor.  This HELP file defines
Xthe storage format and arithmetic representation used by the DSP56000/1
Xfloating point software subroutine library (FPLIB).  The handling of
Xexception cases is also discussed.  Subroutine calling conventions are
Xnot discussed here but are given in the FPCALLS.HLP file.
X
XFPLIB "SINGLE EXTENDED" PRECISION FLOATING POINT FORMAT
X
XFloating point number - (m,e) including mantissa sign
X        Decimal value = m * ( 2 ** ( e - ebias ))
X
X        23_____________________0    23_______________________0
X        | s .      m           |    |    0            e .    |
X        |______________________|    |________________________|
X
Xm = 24 bit mantissa (two's complement, normalized fraction)
X        23 bit mantissa precision plus 1 bit mantissa sign gives
X        precision of approximately 7 decimal digits.  The 24 bit
X        mantissa was chosen to maximize precision with efficient
X        use of the DSP56000 MPY and MAC instructions.
X        A hidden leading 1 is not implemented in this format.
X
X        Binary encoding:  s.xxxxxxx xxxxxxxx xxxxxxxx
X        Bit weight:       0  -1                      -23
X                        -2  2                       2
X
X        Largest positive mantissa    $7FFFFF = +0.99999988079071044921875
X        Smallest positive mantissa   $400000 = +0.5
X        Floating point zero mantissa $000000 = 0
X        Smallest negative mantissa   $BFFFFF = -0.50000011920928955078125
X        Largest negative mantissa    $800000 = -1.0
X        Reserved mantissas           $000001 through $3FFFFF
X                                     $C00000 through $FFFFFF
X
X        Note that all reserved mantissas are illegal since they
X        represent denormalized mantissas.
X
Xe = 14 bit exponent (unsigned integer, biased by ebias = +8191)
X        Stored as a 24 bit unsigned integer with 10 leading zeros.
X        Exponent arithmetic is generally done with 16 bit precision.
X        The 14 bit exponent format was chosen to maximize dynamic
X        range with efficient detection of exponent overflow and
X        exponent underflow.
X
X        Binary encoding:  00000000 00xxxxxx xxxxxxxx.
X        Bit weight:                   13            0
X                                     2             2
X
X        Largest exponent             $003FFF = 2 ** +8192
X        Assumed fixed point exponent $001FFF = 2 ** +0 = +1.0
X        Smallest exponent            $000000 = 2 ** -8191
X        Reserved exponents           $004000 through $FFFFFF
X
X                        14
X        If bit weight  2   is set, exponent overflow has occured.
X                        15
X        If bit weight  2   is set, exponent underflow has occured.
X
X        Note that no distinct exponents are reserved for plus infinity,
X        minus infinity, Not a Number (IEEE NaN), minus zero or
X        denormalized numbers.
X
X
XFPLIB "SINGLE EXTENDED" PRECISION FLOATING POINT NUMBER RANGE
X
XLargest positive floating point number -  m = $7FFFFF, e = $003FFF
X        Decimal value = +0.1090748 E+2467
X
XSmallest positive floating point number - m = $400000, e = $000000
X        Decimal value = +0.9168017 E-2466
X
XSmallest negative floating point number - m = $BFFFFF, e = $000000
X        Decimal value = -0.9168019 E-2466
X
XLargest positive floating point number -  m = $800000, e = $003FFF
X        Decimal value = -0.1090748 E+2467
X
XFloating point zero -                     m = $000000, e = $000000
X        Decimal value = +0.0
X
XNote that the two's complement mantissa does not have equal
Xpositive and negative ranges.  Only sign-magnitude formats
Xpossess this property.  These ranges should be checked after
Xmost arithmetic operations.
X
X
XFPLIB "SINGLE EXTENDED" PRECISION FLOATING POINT DSP56000/1 REGISTER USAGE
X
XSign Only       Mantissa        Exponent        Usage
X                x1              x0              Input only
X                y1              y0              Input only
Xa2              a1              b1              Input and output
X                                r0,n0,m0        Reserved for FPLIB
X
XThe library subroutines do not preserve the contents of these registers
Xunless specifically noted in the function.  Accumulator a usually
Xcontains the mantissa upon return from the subroutine.  Accumulator b
Xusually contains the exponent upon return from the subroutine.
XThe subroutines assume that the input variables are present in the
Xappropriate registers when the subroutine is called.
X
X
XFPLIB "SINGLE EXTENDED" PRECISION FLOATING POINT DSP56000/1 MEMORY USAGE
X
XThe floating point mantissa and exponent may be stored in any
Xlocations in any memory space.  The input and output register
Xvalues are organized so that the long (L:) addressing mode may
Xbe used to load/store both the mantissa and exponent with one
Xinstruction.  If the long addressing mode is used, the mantissa
Xis in X memory and the exponent is in Y memory at the same address.
X
X
XCOMPARISON TO ANSI/IEEE STD 754-1985 STANDARD FOR BINARY FLOATING
XPOINT ARITHMETIC
X
XSince the IEEE Floating Point Arithmetic Standard is well
Xpublicized, it is useful to compare these two floating point
Xformats.  This floating point format (FPLIB) differs from the
XIEEE standard primarily in its handling of floating point exceptions.
XOther differences are noted in the table below.  Conversion between
Xthe IEEE standard format and this format is straight-forward.
X
XCHARACTERISTIC          FPLIB FORMAT            IEEE FORMAT
X--------------          ------------            -----------
X
XMantissa Precision      23 bits                 24 bits
X
XHidden Leading One      No                      Yes
X
XMantissa Format         24 bit Two's            23 bit Unsigned
X                        Complement Fraction     Magnitude Fraction
X
XExponent Width          16 bits (14 bits        8 bits (single)
X                        used)                   11 bits (double)
X
XMaximum Exponent        +8192                   +127 (single)
X                                                +1023 (double)
X
XMinimum Exponent        -8191                   -127 (single)
X                                                -1022 (double)
X
XExponent Bias           +8191                   +127 (single)
X                                                +1023 (double)
X
XFormat Width            48 bits                 32 bits (single)
X                                                64 bits (double)
X
XRounding                Round to Nearest        Round to Nearest
X                                                Round to +Infinity
X                                                Round to -Infinity
X                                                Round to Zero
X
XInfinity Arithmetic     Saturation Limiting     Affine Operations
X
XDenormalized Numbers    No (Forced to Zero)     Yes (With Minimum Exponent)
X
XExceptions              Divide by Zero          Invalid Operations
X                        Overflow                Divide by Zero
X                        Negative Square Root    Overflow
X                                                Underflow
X                                                Inexact Arithmetic
X
X
XIEEE SINGLE PRECISION FORMAT
X
X _31_30______________23_22______________________0
X| s |  8 bit exponent  |     23 bit mantissa    | 
X|___|__________________|________________________|
X
X
XIEEE DOUBLE PRECISION FORMAT
X
X _63_62______________________52_51_______________________________0
X| s |      11 bit exponent     |         52 bit mantissa         | 
X|___|__________________________|_________________________________|
X
X
XAs shown in the table, the FPLIB mantissa precision is one bit less
Xthan the IEEE single precision format.  This is a result of using
Xtwo's complement arithmetic in the DSP56000/1.  The FPLIB exponent
Xwidth is three bits more than the IEEE double precision format.
XThis provides an extremely large (approx. 100,000 dB) dynamic
Xrange which eliminates exponent overflow for most applications.
XIf exponent overflow occurs, the result is limited to the maximum
Xrepresentable floating point number of the correct sign.  If
Xexponent underflow occurs, the result is limited to the minimum
Xrepresentable floating point number, which is zero.  Although
Xthe FPLIB format does not provide the arithmetic safety offered
Xby the IEEE standard, it avoids extensive error checking and
Xexceptions in favor of real-time execution speed and efficient
Ximplementation on the DSP56000/1.  All exception conditions are
Xhandled "in-line" according to predefined rules.  This accepts
Xthe fact that real-time systems have no choice but to provide an
Xoutput with some amount of error if an exception occurs.  It is
Xnot possible to stop execution until the application program
Xdetermines a solution to the problem and fixes it.
X
XOne major difference is the use of affine arithmetic in the IEEE
Xstandard versus the use of saturation arithmetic in the FPLIB format.
XAffine arithmetic gives separate identity to plus infinity, minus
Xinfinity, plus zero and minus zero.  In operations involving these
Xvalues, finite quantities remain finite and infinite quantities
Xremain infinite.  In contrast, this format gives special identity
Xonly to unsigned zero.  This format performs saturation arithmetic
Xsuch that any result out of the representable floating point range
Xis replaced with the closest floating point representation.  Since
Xthe dynamic range of this format is quite large, it is adequate for
Xmost applications.  In the analog world, overflow is analogous to an
Xanalog op amp output clamping at the power supply rails.
X
XThe IEEE floating point standard provides extensive error handling
Xrequired by affine arithmetic, denormalized numbers, signaling Not
Xa Number (NaNs) and quiet NaNs.  It postpones introducing computation
Xerrors by using internal signaling and user traps to process each
Xexception condition.  Computational errors will be introduced by
Xthe application program if the calculation is completed instead of
Xaborting the program.  The FPLIB format introduces computation errors
Xwhen an exception occurs in order to maintain real-time execution.
XAn error flag (L bit in CCR) is set to inform the application program
Xthat an exception has occured.  This bit will remain set until reset
Xby the application program.  The user can then eliminate the exception
Xby algorithm modifications.
X
SHAR_EOF
$TOUCH -am 1126102991 fpdef.hlp &&
chmod 0644 fpdef.hlp ||
echo "restore of fpdef.hlp failed"
set `wc -c fpdef.hlp`;Wc_c=$1
if test "$Wc_c" != "10835"; then
	echo original size 10835, current size $Wc_c
fi
# ============= fprevs.hlp ==============
echo "x - extracting fprevs.hlp (Text)"
sed 's/^X//' << 'SHAR_EOF' > fprevs.hlp &&
X2 FPREVS
X 
X 
X FPLIB - MOTOROLA DSP56000/1 FLOATING POINT SOFTWARE SUBROUTINE LIBRARY
X 
X                 LATEST REVISIONS - VERSION 2.0
X 
X Revision 1.0      August 29, 1986
X Revision 1.1      March  25, 1987
X Revision 2.0      October 5, 1987
X 
X MOTOROLA, INC.
X COPYRIGHT 1986, 1987
X ALL RIGHTS RESERVED
X 
X INTRODUCTION
X 
X FPLIB is a useful set of floating point arithmetic subroutines for the
X Motorola DSP56000/1 digital signal processor.  This HELP file defines
X the filenames, latest version numbers and latest revision date of all
X FPLIB subroutines.  Users should update their FPLIB copies if they do
X not have the latest versions since previous versions may have program
X bugs.  As new FPLIB routines are added, their entry date will be noted
X here.
X        
X  FPLIB       Latest         Latest           First
X Filename     Version     Revision Date     Entry Date
X --------     -------     -------------     ----------
X fpinit         2.0          5-Oct-87        5-Oct-87
X fpadd          2.0          7-Oct-87        5-Oct-87
X fpsub          2.1         15-Oct-87        5-Oct-87
X fpcmp          2.1          3-Nov-87        5-Oct-87
X fpmpy          2.0          5-Oct-87        5-Oct-87
X fpmac          2.1         30-Oct-87        5-Oct-87
X fpdiv          2.0          5-Oct-87        5-Oct-87
X fpscale        2.0          5-Oct-87        5-Oct-87
X fpsqrt         2.0          5-Oct-87        5-Oct-87
X fpneg          2.0          5-Oct-87        5-Oct-87
X fpabs          2.0          5-Oct-87        5-Oct-87
X fpfix          2.0          5-Oct-87        5-Oct-87
X fpfloat        2.0          6-Oct-87        5-Oct-87
X fpfloor        2.0          1-Mar-88        1-Mar-88
X fpceil         2.0          1-Mar-88        1-Mar-88
X fpfrac         2.0          1-Mar-88        1-Mar-88
X 
X 
X 
X 
X
SHAR_EOF
$TOUCH -am 1126103091 fprevs.hlp &&
chmod 0644 fprevs.hlp ||
echo "restore of fprevs.hlp failed"
set `wc -c fprevs.hlp`;Wc_c=$1
if test "$Wc_c" != "1848"; then
	echo original size 1848, current size $Wc_c
fi
exit 0
