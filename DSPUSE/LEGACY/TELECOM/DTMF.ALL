radix h

display off a x y b

change omr 4

change pc 40

change la 0

change lc 0

change sp 0

change sr 0

log off

_COMMENT 

 **ADM0***



_DATA Y 0

 ac800

 11cc00 fe9981 2d8c00 ac180 1f6f00 c4d101 c69e81 2fd480

 1f6380 160dc0 e9f241 13e480 0 0 20237f eeda81

 1a6600 296000 201f80 15945 0 c6605b 3dbdab fea6bc

 1717e 0 d3990e 3d967b fe8e83 1a283 0 e334fc

 3d4579 fe5d7e 1b643 0 f46a6f 3d22a6 fe49be 21262

 0 282537 3c7574 fded9f 22cfe 0 3ea63c 3c5603

 fdd303 25efc 0 54846e 3c03c1 fda105 295d0 0

 67b680 3bad5b fd6a31

_END 

	title	'DTMF DETECTION '

	page	132,66,0,10





;*******************************************************************

;This section does the actual detection of the dual tones as well

;as checking twist and energy.

;*******************************************************************







        opt     rc,mu,cc

det	IDENT	1,1	;20 ms detection



	section	det

	xref	rien,rdlgn,iiraspi,enerac

nbwdw	equ	80

energy	equ	$20

twogrp	equ	$1C

ratio	equ	$60





;******************************************

;threshold values

;******************************************





tmin	equ	@pow(10,-3.5)	;-35dB

mi8	equ	@pow(10,-.8)	;-8dB =10logX

mi4	equ	@pow(10,-.4)	;-4dB =10logX

mi6	equ	@pow(10,-.6)	;-6dB





;******************************************

; data for the filters

;******************************************





wddr	equ 	0	;w1(n-1) w2(n-1),...

cddr	equ 	0	;b0,b1,a1,a2,b2

	org	yhi:

vratio	dc	0.0125	;1/80

	org	pli:





;******************************************

; the analysis will be done

; on 80 samples at 4 Khz (20 ms)

;******************************************





	move	#energy,r2	;r2 -> 8 energies

	move	#twogrp,r1	;r1 -> low and high group

	move	#keybrd,r7	;r7 -> ASCII code table

	move	#ratio,r6	;r6 -> 1/80

	move	#0,x0	

	rep	#$b		;zero in the 11

	move	x0,x:(r2)+	;energies

;

	do #nbwdw,_edwdw

;

	jsr	rdlgln

	move	a,y1

	jsr	enerac

	move	y1,a



;******************************************

; 6th order Band Pass filter for :

; - dial tone rejection

; - low frequency group selection

; the 15 coefficents from the file

; BPF.LOD are located in the Y data

; memory at locations Y:0..$0E

;******************************************



	move 	#wddr,r0	;r0 -> samples

	move	#cddr,r4	;r4 -> coefficients

	move	#2,n0

	jsr	iiraspi

	move 	a,x:(r1)+	;x1(n) stored in x:(r1)

	jsr	enerac



;******************************************

; High Pass filtering  for :

; - high frequency group selection

; The 15 coefficients from the file

; HPF.LOD are located in the Y data

; memory at locations Y:$0D..1D

;******************************************



	move 	y1,a

	jsr	iiraspi

	move 	a,x:(r1)-	;x2(n) stored in x:(r1)

	jsr	enerac



;******************************************

; 8 Band Pass filtering with 

; 8 full wave rectifiers

;******************************************



	move	#1,n0

	do 	#2,_endfwr	;loop on the 2 frequency groups

	move	x:(r1)+,y1

	do	#4,_endgrp	;loop in a group

	move	y1,a

	jsr	iiraspi		;BP biquad for each frequency

	jsr	enerac

_endgrp

	nop

_endfwr

	jsr	rdlgln

_edwdw



;******************************************

; Threshold test and decision

;  look for high group peak

;******************************************



	move	#energy+10,r2	;r2 -> energy(1633hz)

	move	#>3,x0		;x0 = 3 (index of energy max)

	move	x:(r2)-,y0	;y0 = energy max= energy(1633hz)

	move	x:(r2)-,a	;a  = energy(1477hz)

	move 	#3,r3

	do	#3,edcol

	cmp	y0,a	(r3)-	;compare y0 and a

	jlt	<saut		;jump if a<y0 (no max update)

	move	a,y0 		;if a>y0, y0= new max= a

	move 	r3,x0

saut	move	x:(r2)-,a	;a= next energy to check

edcol

;

;******************************************

;  look for low group peak

;******************************************



	move	#>3,x1	a,y1	;x1 = 3 (index of energy max)

				;y1 = energy max = energy(941hz)

	move	x:(r2)-,a	;a = energy (852hz)

	move #3,r3

	do	#3,edrow

	cmp	y1,a	(r3)-		;compare  y1 and a

	jlt	<sau		;jump if a < y1	(no max update)	  	

	move	a,y1		;if a > y1 ,then y1=a

	move 	r3,x1

sau	move	x:(r2)-,a 	;a = next energy to check

edrow

;

;******************************************

;  test if above minimun threshold

;******************************************



	move 	#tmin,a	;a= threshlod min

	cmp	y0,a	;compare max in low group with threshold

	jgt	<rien	;no detection if below threshlod

	cmp	y1,a 	;compare max in high group with threshold

	jgt	<rien	;no detection if below

;

;******************************************

; computer the detected number: 4 x X1 +X0

; (4 x low freq. index + high freq. index)

;******************************************

; 

	move 	x1,a	;a=x1

	asl	a	;a=2. x1

	asl	a	;a=4. x1

	add	x0,a	;a=4.x1+x0

	move	a,n7	;n7= index in keybrd 

;

;******************************************

; check for the twist 

;******************************************

;

	move	y1,b	;b= low group max

	cmp	y0,b	;compare with high group max

	jge	<lowmax	;jump if low group max energy bigger

;

;******************************************

; high group maxminum value > low group maximum value

; +4 db are allowed

;******************************************

; 

hghmax	move	#mi4,x0	;x0=attenaution

	mpy	x0,y0,a	;a= high group max -4dB

	cmp	y1,a	;compare with high group

	jge	<rien	;no detect if difference > than 8 dB

;

;******************************************

; low group max. can be 8dB higher than high group

;******************************************

;

lowmax	move	#mi8,x1	;x1= attenuation

	mpy	x1,y1,a	;a=low group max- 8dB

	cmp	y0,a	;compare with high group

	jge	<rien	;no detect if difference > than 4 dB

;

;******************************************

; in each group, the max should be

; at least +8 db above the other frequencies

;******************************************

;

	move	#mi8,x1		;x1=attenuation

	mpy	x1,y1,a	#>2,y1

	move	#energy+3,r2	;prepare r2 for coming test

	move	#>1,b	

	move	x:(r2)+,x0

	do	#4,endlw

	cmp	x0,a		;compare with lowmax-8dB

	jge	<lit		;continue if max-8dB bigger

 	asl	b

lit	move	x:(r2)+,x0	;x0=energy



endlw	cmp	y1,b 		;test b;if more than one

	jgt	<rien		;energy is bigger -> no dectect

;

	move	#>1,b

	mpy	x1,y0,a		;a=highmax-8dB

	do	#4,endhg

	cmp	x0,a		;compare with lowmax-8dB

	jge	<lit2		;continue if max-8dB bigger

	asl	b

lit2	move	x:(r2)+,x0	;x0=energy



endhg	cmp	y1,b   		;test b;if more than one

	jgt	<rien		;energy is bigger -> no dectect

;

	endsec

	end

	title	'DTMF RECEIVER  AND GENERATOR MAIN PROGRAM'					     	

	page	132,66,0,10

;

;

;

;**********************************************************************

;This program is a single channel receiver and generator program.

;It uses sections det and sub which must be linked with this

;program to run

;**********************************************************************



        opt     rc,mu



dtmf	ident	1,1	;main

 









;**********************************************************************

;The following section loads definitions in X memory starting at xhi

;**********************************************************************









	SECTION define





	xdef	misc,keybrd,pret,ret,pos,num

	org	xhi:

misc	dc	$010000,$010000,tempo,1,troisl,$30

keybrd	dc	'1','2','3','A','4','5','6','B','7','8','9'

	dc	'C','*','0','#','D'	

pret	dc	$0a,$0d,'R','E','A','D','Y',':',$0a,$0d,

ret	dc	$0d,$0a

pos	dc	$20

num	dc	'0','0','0','1','0','2','0','3','0','4','0','5'

	dc	'0','6','0','7','0','8','0','9','1','0','1','1'

	dc	'1','2','1','3','1','4','1','5','1','6','1','7'

	dc	'1','8','1','9','2','0','2','1','2','2','2','3'

	dc	'2','4','2','5','2','6','2','7','2','8','2','9'

	dc	'3','0','3','1','3','2','3','3','3','4','3','5'

	dc	'3','6','3','7','3','8','3','9','4','0','4','1'

	dc	'4','2','4','3','4','4','4','5','4','6','4','7'

	endsec





;**********************************************************************

;The following section sets up the interupt vectors on the SCI receive

;port where the numbers 0-9 ABCD * or # are selected for tone

;generation

;**********************************************************************



	section vector

	org p:$0014       ;this is the SCI receive interupt vector location

	jsr tone          ;this is the generate subroutine

	org p:$0016       ;This is the SCI receive with exception vector

	jsr tone

	endsec









;**********************************************************************

;This section sets up the SSI and SCI tto transmit and receive.

;The SSI port is used to transmit and recive A-law data to/from

;a PCM codec.  The SCI port is used to display the results of

;detection to a RS232 terminal as well as to take inputs from

;the RS232 terminal to generate the desired tones.

;**********************************************************************









	section	periphials 

 	nolist

	include '\dsp56000.asm\ioequ'   ;This include file contains

	                                ;the i/o bit definitions

	list

	org	pli:

	ori #$03,mr                     ;Mask the interupts

	movep	#$c000,x:$ffff





;**************************************

; first program PORT A & OPERATING MODE

;**************************************



        movep   #$0,x:M_BCR	; no wait states

        move    #$4,omr		; mode 0 /ROM enable

		move	#M_SR,r6	;r6 -> ssi status reg.







;***********

; sci setup

;***********





;**************************************

;The SCI port is set up in the 10 bit

;asynchronous mode to operate with an

;RS232 terminal. The receiver and

;transmitter are enabled as well as the

;receiver interupt.

;**************************************



		movep	#0,x:M_SCR              ;zero the control register 

		bset	#M_WDS1,x:M_SCR         ;Set it for 10 bits 

        bset    #M_TE,x:M_SCR           ; enable the transmitter ( WDS=0 )

		bset	#M_RE,x:M_SCR           ;enable the receiver 

		bset	#M_RIE,x:M_SCR          ;enable the reciever interupt

        movep   #32,x:M_SCCR            ; CD=32 for divide by 33(2.5MHz/33)





;***********

; ssi setup

;***********





;**************************************

;The SSI is configured in the normal 

;mode with an external clock and in

;the synchronousmode.  Interupts are 

;not used but the RDF/TDE flags are.

;**************************************



        movep   #$1F03,x:M_CRA          ; PSR=0 , WL=0 , DC4-0=31 ,PM7-0=3

        movep   #$200,x:M_CRB 	        ; RIE=0,TIE=RE=TE=0 , MOD=0 , GCK=0

                                        ; SYN=1 , FSL=0 , SCKD=1 (int clk )

                                        ; SCD2=1(int TDE/RDE),OF(1:0)=0

        movep   #$1ff,x:M_PCC           ; set CC(8:3) as SSI pins

                                        ; set CC(2;0) as SCI pins

		movep	#$0,x:M_SR

        move    #$0,sr                  ; no mask ( enable all levels )

        movep	#$3200,x:M_CRB		    ; RIE=0,TIE=0, RE,TE = 1 

		andi	#$fc,mr                 ;unmask the interupts



	endsec





;**********************************************************************

;The following is the main section of the program which initializes

;the RS232 terminal and keeps track of detections to report to the

;RS232 terminal

;**********************************************************************

	section	main1

	org	pli:

; 

	xdef	tempo,troisl,rien,enc              ;internal subroutines

	xref	ready,misc,keybrd,pret,ret,pos,num ;external subroutines

;

tempo	equ	$2C

troisl	equ	16*3

thrshld	equ	$019000	;-35dB

	move	#pret,r0	;for ready message

	move	#10,n0		;on the display

	jsr	ready		    ;go to write to display

	move	#misc+1,r5 	; r5-> former detections

	move	#$a,m2		;r2 mod 11 for energies

	move	#$1,m1		;r1 mod 1 for two groups

	bset	#16,x:(r5)-	;last one = bidon

	bset	#16,x:(r5)+	;last-2 =bidon

rien

	move	x:(r5)-,a	;a=last one

	move	a,x:(r5)+	;last-2=last one

	bset	#16,x:(r5)+	;last one=bidon

	move	x:(r5)+,a	;a= 20ms silence decounter

	move	x:(r5)-,x0		;x0=1

	sub	x0,a

	tst	a	a,x:(r5)-

	jge	<enc		;if not zero, comtinue



;**************************************

;  if big silence,write num and RC,init tempo

;**************************************



	move	#pos,r0		;SPACE

	move	#1,n0		;

	jsr	ready		

	move	#num,r4		;r4 -> ascii(00)	

	move	n1,a		;a=num

	asl	a	#$1,n5	;a= 2*num, N5 == offset for tempo update

	move	a,n4		;n4=2*num

	move	#0,n1		;num=0

	move	#2,n0

	lua	(r4)+n4,r0	;r0=ascii(num)

	jsr	ready		;write num

	move	#ret,r0

	tst	a 	#1,n0

	jeq	nolf

	move	#2,n0

nolf	jsr	ready		

	move	#>tempo,x0

	move	x0,x:(r5+n5)

enc

	endsec





;**********************************************************************

;Section det is linked with this program and contains the acual

;detection routines used for receiving and detecting tones

;**********************************************************************



	section	det 

	endsec





;**********************************************************************

;The next section of code does several things for receiving tones and 

;and also contains the code which genrates the tone when there is an

;key depressed on the RS232 terminal causing an SCI receive interupt.

;**********************************************************************



	section write	

	org	pli:

	xref	ready,misc,keybrd,pret,ret,pos,num,enc

	xdef 	tone,toneptr,generate

;

msk13	equ	$fff800

inv		equ	$d5

	nolist

	include '\dsp56000.asm\ioequ'        

	list





;**************************************

;The current detected number is

;compared with the last detected 

;number to see if it has changed.

;**************************************



	move	n7,y0			;y0 = detected number

	move	x:(r5)-,b		; b = last one

	move	x:(r5),a		; a = last -2

	move 	b,x:(r5)+		; last one -> last -2

	cmp	y0,a	y0,x:(r5)	;y0 -> last one

	jeq	<rien			;nothing if y0 =last-2

	cmp	y0,b			;compare y0 with last one

	jne	<enc			;double dectect necessary



;**************************************

; number detected and written

;**************************************





	move	n1,r4		;r4= num

	move	x:(r7+n7),x0	;x0= ascii code of detected number

	movep	x0,x:M_STXL	;write code to RS232 terminal

	lua	(r4)+,n1	;increment n1 (num counter)

	move	#>tempo,x0  	;init tempo

	move	x0,x:(r5+n5) 

	jmp	<enc		;go to another detection



	jmp past



;**************************************

;input and generate subroutine

;which is called at the SCI interupt

;vector location.

;All register and pointers which are

;used in this subroutine are stored 

;to memory first so that the correct

;values may be restored at the end

;before returning to the program.

;**************************************







tone

   ;   save register state

	move	a,l:$61

	move 	x,l:$62

	move	n4,y:$63



   ;   receive data from sci port

	movep	x:M_SRXL,a



	jsr	toneptr



	move	#$f10,x0	; $f10 identifies bad i/o

	cmp	x0,a



	jeq notone



   ;   save register state

	move 	b,l:$64

	move	y,l:$65

	move	r3,y:$66

	move	r4,y:$67

	move	r5,y:$68



	jsr generate



   ; restore second save

	move	l:$64,b

	move	l:$65,y

	move	y:$66,r3

	move	y:$67,r4

	move	y:$68,r5

notone 	



   ; restore first save

	move	l:$61,a

	move 	l:$62,x

	move	y:$63,n4

	rti



;**************************************

;subroutine which determines the

;digit from the ascii input

;this is done by comparing the ascii

;input to the ascii hex representation

;of 0-9, a-d and the * and #. If there

;is no match then there is no tone 

;generated.

;If there is a match then the n4 

;register will contain the location

;tone coefficients to be used for

;generation.

;**************************************





toneptr

	move 	#>$39,x0

	cmp	x0,a	#>$30,x0

	jgt	alpha

	cmp	x0,a

	jlt 	punt1

	sub	x0,a

	move 	a1,n4

	rts



alpha

	move 	#>$61,x0

	cmp	x0,a	#>$64,x0

	jlt	badio

	cmp	x0,a	#>$57,x0

	jgt 	badio

	sub	x0,a

	move	a1,n4

	rts





punt1

	move	#>$23,x0

	cmp 	x0,a

	jne	punt2

	move	#$e,n4

	rts





punt2

	move 	#>$2a,x0

	cmp 	x0,a

	jne	badio

	move 	#$f,n4

	rts



badio

	move 	#$f10,a

	rts

	



;**************************************

;The generate subroutine actually 

;generates the points in the tone

;and then compresses the data and

;outputs it to the SSI port.  An

;second order oscillator is used to

;generate the tones. Each tone only

;needs one coefficient.

;**************************************



generate

	move	#$dd,r3

	move	#$e0,r4

	move	#$da,r5

	move	l:(r4+n4),x

	move	#>$400000,y1

	clr	a	y1,y0

	clr	b 	y0,x:(r5)+



   ;   some clue goes here

	do 	#<$360,loop1

	mac	-y0,x0,a

	neg	a

	mac	y0,x0,a

	mac	-y1,x1,b

	neg	b

	mac	y1,x1,b	

	tfr	y0,a	a,y0

	tfr	y1,b	b,y1

	move 	x0,x:(r5)-	b,y:(r3)+

	move	y1,y:(r3)+

	move	x:(r5)+,x0 	a,y:(r3)

	mpy	x0,y1,b

	mac	x0,y0,b

	move 	b1,y:$fffe

	tfr	b,a		#msk13,x0

	abs	a

	and	x0,a	#<inv,y1

	do 	#8,enloop

	jes 	<quit

	asl	a

enloop

	jmp	<seg

quit	lsl	a

	move 	lc,a2

	enddo

seg	rep	#3

	asr	a

	lsl	b

	ror	a

	eor	y1,a

	tfr 	a,b	b,a

	movep	b1,x:M_TX

	move	y:(r3)-,a

	move	y:(r3)-,y1

	move	x:(r5),x0	y:(r3),b     

	rep	#<$4c9	

	nop

loop1

	rts



past

	endsec

	end

BASE			XLI:$0,XHI:$40,YHI:$60,PLI:$40,PHI:$1d0

	title	'MULTICHANNEL DTMF RECEIVER MAIN PROGRAM'

;	SSI in network mode

	page	132,72,0,10

;**************

;;5/31/87 ; ec

; dtmfmstr.asm

;**************

;  Multichannel DTMF receiver master program:

;    	-using the SSI in network mode 

;  	-the SCI is used to display the results

;       

;	Polled I/O version

;

        opt     rc,mu,cc



dtmfmtr	ident	1,1	;main

 

; the following section define the location

; of the data in the X & Y memories

;

;********************************

	section divers

	xdef	keybrd,pret,pos

	xdef	ratio,samples,misc

	xdef	energy,twogrp,wddr,cddr

;

;	Data in internal Y memory

;

	org	xi:0

wddr	dsm	144		; memory of all filters

	org	xi:$90

twogrp	dsm	12		; high and low group input

	org	xi:$c0

energy	dsm	48		; 6*8 energies

;

;	Data in internal Y memory	

;

	org	yi:0

cddr	ds	60		; filter coef.

	org	yi:$40

samples	ds	6		; 6 input samples

	org	yi:$50

keybrd	ds	16		; data for display

pret	ds	61		; data for init display

pos	ds	18		; data for display result

ratio	ds	1		; energy division ratio

	org	yi:$f0

misc	dsm	12		; 6 lastone,lastone-1

;

	endsec

;********************************

;

	section	rezet

start	equ	$40	

	org	p:0

	jmp	<start

	endsec

;

;********************************

	section pcoeff

	xdef	pcddr

;temporary storage of

;filter coef. after bootstrap

	org	p:1

pcddr	dc	$0ac800,$11cc00,$fe9981,$2d8c00,$0ac180 

	dc	$1f6f00,$c4d101,$c69e81,$2fd480,$1f6380 

	dc	$160dc0,$e9f241,$13e480,$000000,$000000

	dc	$20237f,$eeda81,$1a6600,$296000,$201f80 

	dc	$015945,$000000,$c6605b,$3dbdab,$fea6bc

 	dc	$01717e,$000000,$d3990e,$3d967b,$fe8e83 

	dc	$01a283,$000000,$e334fc,$3d4579,$fe5d7e 

	dc	$01b643,$000000,$f46a6f,$3d22a6,$fe49be 

	dc	$021262,$000000,$282537,$3c7574,$fded9f 

	dc	$022cfe,$000000,$3ea63c,$3c5603,$fdd303 

	dc	$025efc,$000000,$54846e,$3c03c1,$fda105 

	dc	$0295d0,$000000,$67b680,$3bad5b,$fd6a31

	endsec

;

;********************************

; the following section transferts data 

; from P to Y memory after the bootstrap

;

	section	transfert

	xref	keybrd,pkeybrd,cddr,pcddr

;

	org	pli:

	move	#keybrd,r4

	move	#pkeybrd,r0

	do	#96,end_trf

	move	p:(r0)+,x0

	move	x0,y:(r4)+

end_trf

	move	#cddr,r4

	move	#pcddr,r0

	do	#60,end_trf1

	move	p:(r0)+,x0

	move	x0,y:(r4)+

end_trf1



	endsec

;********************************

;

	section	initperiph 

 	nolist

	include '\dsp56000.asm\ioequ'        

	list

	org	pli:

;

; SSI configuration:

; -network mode;internal clock;synchronous mode.

; -does not use interrupt but RDF/TDE flags.

; -Alaw expansion is using algln11 and 

;  DSP56001 internal data ROM address X:$180

;

;

acc     equ     $2222           ; external access time X_Y_P_IO

;

;  SSI setup

;**************

ps      equ     0<<M_PSR        ; change 0 to 1 for divide by 8

wl      equ     0<<M_WL0        ; change 0 to 3/1/2 for 24/12/16 bits/word

dc      equ     26<<8           ; used for 27 slots/frame in NW

pm      equ     2               ; to gen the 8x27(cdc)x8(bit)=1.728MHz rate

;**************

;  SCI setup

;**************

wl0	equ	6<<M_WDS0	

sbk	equ	0<<M_SBK

;

; start

;******

; first program PORT A & OPERATING MODE

start	move    #$4,omr		; mode 0 /ROM enable

        movep   #acc,x:M_BCR    ; wait states

;***********

; ssi setup

;***********

; step 1 of initialization of SSI is RESET ( already performed )

; step 2 of initialization of SSI

; start programming the SSI

        movep   #(ps|wl|dc|pm),x:M_CRA  ; PSR=0 , WL=0 , DC=19 , PM=3

        movep   #>$0A3C,x:M_CRB         ; RIE=0 , TIE=0 , RE=0  , TE=0

                                        ; MOD=0 , GCK=0 , SYN=1 , FSL=1

                                        ; *     , *     , SCKD=1, SCD2=1,

                                        ; SCD1=1, SCD0=1, OF1=0 , OF0=0

; start programming the SCI

	movep	#(sbk|wl0),x:M_SCR

        bset    #M_TE,x:M_SCR           ; enable the transmitter ( WDS=0 )

        movep   #269,x:M_SCCR           ; CD=269 for divide by 270

					; 320k/270=1185 baud #1200 baud)

; enable the SSI

	bclr	#4,x:M_PCDDR		;sc1/pc4 input	ack

	bclr	#1,x:M_PCDDR		;txd/pc1 input  busy

	bset	#0,x:M_PCDDR		;PC0 output  reset

        movep   #$1e4,x:M_PCC           ; set CC(8:3) as SSI pins

                                        ; set CC(2;1) as SCI pins

 	endsec

;

;********************************

	section	main1

	org	pli:

; 

	nolist

	include '\dsp56000.asm\ioequ'        

	list

;

	xdef	rien,enc

	xref	ready,misc,keybrd,pret,ret,pos,num,temp

;

; misc. init

;

	bclr 	#0,x:M_PCD		; start reset display

	jsr	temp			;temp

	bset 	#0,x:M_PCD		;end reset display

	jsr	temp			;temp

; 

	move	#pret,r6	;for ready message

	move	#61,n6		;on the display

	jsr	ready		;go to write to display

;

	move	#8,n2		;offset for energies      

	move	#2,n5		;offset for detect/last/lastone

;

	move	#(6*$18)-1,m0	;modulo 8f for filter samples

	move	#11,m1		;r1 mod 12 for two groups

	move	#(6*8)-1,m2	;modulo 48 for energies

	move	#$3b,m4		;modulo 3b for filter coefficient

	move	#$b,m5		;modulo 12 for last-1 & lastone

;

	move	#misc+1,r5 	; r5-> former detections

	rep	#12

	bset	#16,y:(r5)+	;last one &last-2= bidon

;

rien

enc

	endsec

;********************************

;

	section	detect 

; 	the linker will insert the 

;    	detection routine

	endsec

;

;********************************

	section	main2

	org	pli:

	xref	ready,misc,keybrd,pret,ret,pos,num,enc

;

	nolist

	include '\dsp56000.asm\ioequ'        

	list

;

	move	#keybrd,r7	;r7 -> ASCII code table

	move 	#pos,r6

	move	#3,n6

	move	#2,n3

	move	#$40,n4		

	move	#>1,y1

;

	do	#6,_edwrt

; 

	jset	#$10,x:(r5),ryen	;nothing if no detection

;	

; compare with last detection

;

	move	x:(r5),y0		;y0 = detected number

	move	y:(r5)-,b		; b = last one

	move	y:(r5),a		; a = last -2

	move 	b,y:(r5)+		; last one -> last -2

	cmp	y0,a	y0,y:(r5)	;y0 -> last one

	jeq	<ryen			;nothing if y0 =last-2

	cmp	y0,b			;compare y0 with last one

	jne	<enk			;double dectect necessary

;

; number detected and written

;

	move	y0,n7			;n7=  detected number

;

	lua	(r5)-,r5

	move	r6,r3

	move	y:(r7+n7),x0	;x0= ascii code of detected number

	move	x0,y:(r3+n3)	;write code to RS232 terminal

	jsr	ready	    	;go to write to display

	lua	(r6)-n6,r6

	move	n4,a

	jmp	<paseff		; go to another detection

;	

ryen	move	y:(r5)-,a	;lastone->last-2

	move	a,y:(r5)+

	bset	#16,y:(r5)-	;last one=bidon

	move	x:(r5),a

	sub	y1,a

	jne	<paseff

	move	r6,r3

	move	#>$20,x0

	move	x0,y:(r3+n3)

	jsr	ready			;go to write to display

	lua	(r6)-n6,r6

	move	#$ffffff,a

paseff	move	a,x:(r5)+

;

enk	lua	(r5)+n5,r5

	lua	(r6)+n6,r6

;

_edwrt

	jmp	<enc

	endsec

;

;********************************

;	section containing data

;	to be transfered to the Y

;	memory after the bootstrap

;

	section	PtoYmem

	xdef	pkeybrd

	org	pli:

pkeybrd	dc	'1','2','3','A','4','5','6','B','7','8','9'

	dc	'C','*','0','#','D'	

ppret	dc	$0e,$1b,0,'D','I','A','L','E','R','1',':'

	dc	$1b,$0D,'D','I','A','L','E','R','2',':'

	dc	$1b,$1A,'D','I','A','L','E','R','3',':'

	dc	$1b,$80,'D','I','A','L','E','R','4',':'

	dc	$1b,$8D,'D','I','A','L','E','R','5',':'

	dc	$1b,$9A,'D','I','A','L','E','R','6',':'

ppos	dc	$1b,$00+$0A,

	dc	$1b,$0D+$0A,

	dc	$1b,$1A+$0A,

	dc	$1b,$80+$0A,

	dc	$1b,$8D+$0A,

	dc	$1b,$9A+$0A,

pratio	dc	0.0125		;1/80

;

	endsec

;

	end





BASE			XLI:$0,XHI:$40,PLI:$40,PHI:$180

	title	'DTMF RECEIVER  AND GENERATOR MAIN PROGRAM'					     	
	page	132,66,0,10
;
;
;
;**********************************************************************
;This program is a single channel receiver and generator program.
;It uses sections det and sub which must be linked with this
;program to run
;**********************************************************************

        opt     rc,mu

dtmf	ident	1,1	;main
 




;**********************************************************************
;The following section loads definitions in X memory starting at xhi
;**********************************************************************




	SECTION define


	xdef	misc,keybrd,pret,ret,pos,num
	org	xhi:
misc	dc	$010000,$010000,tempo,1,troisl,$30
keybrd	dc	'1','2','3','A','4','5','6','B','7','8','9'
	dc	'C','*','0','#','D'	
pret	dc	$0a,$0d,'R','E','A','D','Y',':',$0a,$0d,
ret	dc	$0d,$0a
pos	dc	$20
num	dc	'0','0','0','1','0','2','0','3','0','4','0','5'
	dc	'0','6','0','7','0','8','0','9','1','0','1','1'
	dc	'1','2','1','3','1','4','1','5','1','6','1','7'
	dc	'1','8','1','9','2','0','2','1','2','2','2','3'
	dc	'2','4','2','5','2','6','2','7','2','8','2','9'
	dc	'3','0','3','1','3','2','3','3','3','4','3','5'
	dc	'3','6','3','7','3','8','3','9','4','0','4','1'
	dc	'4','2','4','3','4','4','4','5','4','6','4','7'
	endsec


;**********************************************************************
;The following section sets up the interupt vectors on the SCI receive
;port where the numbers 0-9 ABCD * or # are selected for tone
;generation
;**********************************************************************

	section vector
	org p:$0014       ;this is the SCI receive interupt vector location
	jsr tone          ;this is the generate subroutine
	org p:$0016       ;This is the SCI receive with exception vector
	jsr tone
	endsec




;**********************************************************************
;This section sets up the SSI and SCI tto transmit and receive.
;The SSI port is used to transmit and recive A-law data to/from
;a PCM codec.  The SCI port is used to display the results of
;detection to a RS232 terminal as well as to take inputs from
;the RS232 terminal to generate the desired tones.
;**********************************************************************




	section	periphials 
 	nolist
	include '\dsp56000.asm\ioequ'   ;This include file contains
	                                ;the i/o bit definitions
	list
	org	pli:
	ori #$03,mr                     ;Mask the interupts
	movep	#$c000,x:$ffff


;**************************************
; first program PORT A & OPERATING MODE
;**************************************

        movep   #$0,x:M_BCR	; no wait states
        move    #$4,omr		; mode 0 /ROM enable
		move	#M_SR,r6	;r6 -> ssi status reg.



;***********
; sci setup
;***********


;**************************************
;The SCI port is set up in the 10 bit
;asynchronous mode to operate with an
;RS232 terminal. The receiver and
;transmitter are enabled as well as the
;receiver interupt.
;**************************************

		movep	#0,x:M_SCR              ;zero the control register 
		bset	#M_WDS1,x:M_SCR         ;Set it for 10 bits 
        bset    #M_TE,x:M_SCR           ; enable the transmitter ( WDS=0 )
		bset	#M_RE,x:M_SCR           ;enable the receiver 
		bset	#M_RIE,x:M_SCR          ;enable the reciever interupt
        movep   #32,x:M_SCCR            ; CD=32 for divide by 33(2.5MHz/33)


;***********
; ssi setup
;***********


;**************************************
;The SSI is configured in the normal 
;mode with an external clock and in
;the synchronousmode.  Interupts are 
;not used but the RDF/TDE flags are.
;**************************************

        movep   #$1F03,x:M_CRA          ; PSR=0 , WL=0 , DC4-0=31 ,PM7-0=3
        movep   #$200,x:M_CRB 	        ; RIE=0,TIE=RE=TE=0 , MOD=0 , GCK=0
                                        ; SYN=1 , FSL=0 , SCKD=1 (int clk )
                                        ; SCD2=1(int TDE/RDE),OF(1:0)=0
        movep   #$1ff,x:M_PCC           ; set CC(8:3) as SSI pins
                                        ; set CC(2;0) as SCI pins
		movep	#$0,x:M_SR
        move    #$0,sr                  ; no mask ( enable all levels )
        movep	#$3200,x:M_CRB		    ; RIE=0,TIE=0, RE,TE = 1 
		andi	#$fc,mr                 ;unmask the interupts

	endsec


;**********************************************************************
;The following is the main section of the program which initializes
;the RS232 terminal and keeps track of detections to report to the
;RS232 terminal
;**********************************************************************
	section	main1
	org	pli:
; 
	xdef	tempo,troisl,rien,enc              ;internal subroutines
	xref	ready,misc,keybrd,pret,ret,pos,num ;external subroutines
;
tempo	equ	$2C
troisl	equ	16*3
thrshld	equ	$019000	;-35dB
	move	#pret,r0	;for ready message
	move	#10,n0		;on the display
	jsr	ready		    ;go to write to display
	move	#misc+1,r5 	; r5-> former detections
	move	#$a,m2		;r2 mod 11 for energies
	move	#$1,m1		;r1 mod 1 for two groups
	bset	#16,x:(r5)-	;last one = bidon
	bset	#16,x:(r5)+	;last-2 =bidon
rien
	move	x:(r5)-,a	;a=last one
	move	a,x:(r5)+	;last-2=last one
	bset	#16,x:(r5)+	;last one=bidon
	move	x:(r5)+,a	;a= 20ms silence decounter
	move	x:(r5)-,x0		;x0=1
	sub	x0,a
	tst	a	a,x:(r5)-
	jge	<enc		;if not zero, comtinue

;**************************************
;  if big silence,write num and RC,init tempo
;**************************************

	move	#pos,r0		;SPACE
	move	#1,n0		;
	jsr	ready		
	move	#num,r4		;r4 -> ascii(00)	
	move	n1,a		;a=num
	asl	a	#$1,n5	;a= 2*num, N5 == offset for tempo update
	move	a,n4		;n4=2*num
	move	#0,n1		;num=0
	move	#2,n0
	lua	(r4)+n4,r0	;r0=ascii(num)
	jsr	ready		;write num
	move	#ret,r0
	tst	a 	#1,n0
	jeq	nolf
	move	#2,n0
nolf	jsr	ready		
	move	#>tempo,x0
	move	x0,x:(r5+n5)
enc
	endsec


;**********************************************************************
;Section det is linked with this program and contains the acual
;detection routines used for receiving and detecting tones
;**********************************************************************

	section	det 
	endsec


;**********************************************************************
;The next section of code does several things for receiving tones and 
;and also contains the code which genrates the tone when there is an
;key depressed on the RS232 terminal causing an SCI receive interupt.
;**********************************************************************

	section write	
	org	pli:
	xref	ready,misc,keybrd,pret,ret,pos,num,enc
	xdef 	tone,toneptr,generate
;
msk13	equ	$fff800
inv		equ	$d5
	nolist
	include '\dsp56000.asm\ioequ'        
	list


;**************************************
;The current detected number is
;compared with the last detected 
;number to see if it has changed.
;**************************************

	move	n7,y0			;y0 = detected number
	move	x:(r5)-,b		; b = last one
	move	x:(r5),a		; a = last -2
	move 	b,x:(r5)+		; last one -> last -2
	cmp	y0,a	y0,x:(r5)	;y0 -> last one
	jeq	<rien			;nothing if y0 =last-2
	cmp	y0,b			;compare y0 with last one
	jne	<enc			;double dectect necessary

;**************************************
; number detected and written
;**************************************


	move	n1,r4		;r4= num
	move	x:(r7+n7),x0	;x0= ascii code of detected number
	movep	x0,x:M_STXL	;write code to RS232 terminal
	lua	(r4)+,n1	;increment n1 (num counter)
	move	#>tempo,x0  	;init tempo
	move	x0,x:(r5+n5) 
	jmp	<enc		;go to another detection

	jmp past

;**************************************
;input and generate subroutine
;which is called at the SCI interupt
;vector location.
;All register and pointers which are
;used in this subroutine are stored 
;to memory first so that the correct
;values may be restored at the end
;before returning to the program.
;**************************************



tone
   ;   save register state
	move	a,l:$61
	move 	x,l:$62
	move	n4,y:$63

   ;   receive data from sci port
	movep	x:M_SRXL,a

	jsr	toneptr

	move	#$f10,x0	; $f10 identifies bad i/o
	cmp	x0,a

	jeq notone

   ;   save register state
	move 	b,l:$64
	move	y,l:$65
	move	r3,y:$66
	move	r4,y:$67
	move	r5,y:$68

	jsr generate

   ; restore second save
	move	l:$64,b
	move	l:$65,y
	move	y:$66,r3
	move	y:$67,r4
	move	y:$68,r5
notone 	

   ; restore first save
	move	l:$61,a
	move 	l:$62,x
	move	y:$63,n4
	rti

;**************************************
;subroutine which determines the
;digit from the ascii input
;this is done by comparing the ascii
;input to the ascii hex representation
;of 0-9, a-d and the * and #. If there
;is no match then there is no tone 
;generated.
;If there is a match then the n4 
;register will contain the location
;tone coefficients to be used for
;generation.
;**************************************


toneptr
	move 	#>$39,x0
	cmp	x0,a	#>$30,x0
	jgt	alpha
	cmp	x0,a
	jlt 	punt1
	sub	x0,a
	move 	a1,n4
	rts

alpha
	move 	#>$61,x0
	cmp	x0,a	#>$64,x0
	jlt	badio
	cmp	x0,a	#>$57,x0
	jgt 	badio
	sub	x0,a
	move	a1,n4
	rts


punt1
	move	#>$23,x0
	cmp 	x0,a
	jne	punt2
	move	#$e,n4
	rts


punt2
	move 	#>$2a,x0
	cmp 	x0,a
	jne	badio
	move 	#$f,n4
	rts

badio
	move 	#$f10,a
	rts
	

;**************************************
;The generate subroutine actually 
;generates the points in the tone
;and then compresses the data and
;outputs it to the SSI port.  An
;second order oscillator is used to
;generate the tones. Each tone only
;needs one coefficient.
;**************************************

generate
	move	#$dd,r3
	move	#$e0,r4
	move	#$da,r5
	move	l:(r4+n4),x
	move	#>$400000,y1
	clr	a	y1,y0
	clr	b 	y0,x:(r5)+

   ;   some clue goes here
	do 	#<$360,loop1
	mac	-y0,x0,a
	neg	a
	mac	y0,x0,a
	mac	-y1,x1,b
	neg	b
	mac	y1,x1,b	
	tfr	y0,a	a,y0
	tfr	y1,b	b,y1
	move 	x0,x:(r5)-	b,y:(r3)+
	move	y1,y:(r3)+
	move	x:(r5)+,x0 	a,y:(r3)
	mpy	x0,y1,b
	mac	x0,y0,b
	move 	b1,y:$fffe
	tfr	b,a		#msk13,x0
	abs	a
	and	x0,a	#<inv,y1
	do 	#8,enloop
	jes 	<quit
	asl	a
enloop
	jmp	<seg
quit	lsl	a
	move 	lc,a2
	enddo
seg	rep	#3
	asr	a
	lsl	b
	ror	a
	eor	y1,a
	tfr 	a,b	b,a
	movep	b1,x:M_TX
	move	y:(r3)-,a
	move	y:(r3)-,y1
	move	x:(r5),x0	y:(r3),b     
	rep	#<$4c9	
	nop
loop1
	rts

past
	endsec
	end
asm56000 -b -l %2

asm56000 -b -l %3

asm56000 -b -l %4

lnk56000 -b%1.lod -m -r %2 %3 %4



Motorola DSP56000 Macro Cross Assembler  Version 2.01  89-02-13  11:20:35  goertzel.asm  Page 1







1      

2                                  section goertzel

3                                                  opt     mu,cc,mex,nomd

4                                                  include 'StdDefs'

716                                                xdef    goe_it

717    

718                                      ;***********************************************************************************************

719                                      ;

720                                      ; Perform one iteration of Goertzel algorithm for four channels

721                                      ;

722                                      ;***********************************************************************************************

723    

724       P:0000 0D0000  [4 -        4]  goe_it    jsr     <win_calc                         ; calculate    windowing function

725       P:0001 698000  [2 -        6]            move                          y:<n_samps,r1 ; read number of samples since start

726       P:0002 300000  [2 -        8]            move              #<ch1_mem,r0            ; set up data pointer for channel 1

727       P:0003 44F000  [4 -       12]            move              x:DTMF_IN,x0            ; read channel 1 data from RX reg. 

                 000000

728       P:0005 205900  [2 -       14]            move              (r1)+                   ;increment count

729       P:0006 690000  [2 -       16]            move                          r1,y:<n_samps ; store new count

730       P:0007 0D0000  [4 -       20]            jsr     <goertzel                         ; process channel 1

731       P:0008 300000  [2 -       22]            move              #<ch2_mem,r0            ; set up data pointer for channel 2

732       P:0009 44F000  [4 -       26]            move              x:DTMF_IN+1,x0          ; read channel 2 data from RX reg.

                 000000

733       P:000B 0D0000  [4 -       30]            jsr     <goertzel                         ; process channel 2

734       P:000C 300000  [2 -       32]            move              #<ch3_mem,r0            ; set up data pointer for channel 3

735       P:000D 44F000  [4 -       36]            move              x:DTMF_IN+2,x0          ; read channel 3 data from RX reg.

                 000000

736       P:000F 0D0000  [4 -       40]            jsr     <goertzel                         ; process channel 3

737       P:0010 300000  [2 -       42]            move              #<ch4_mem,r0            ; set up data pointer for channel 4

738       P:0011 44F000  [4 -       46]            move              X:DTMF_IN+3,x0          ; read channel 4 data from RX reg.

                 000000

739       P:0013 0D0000  [4 -       50]            jsr     <goertzel                         ; process channel 4

740       P:0014 300000  [2 -       52]            move              #<ch5_mem,r0            ; set up data pointer for channel 5

741       P:0015 44F000  [4 -       56]            move              X:DTMF_IN+4,x0          ; read channel 5 data from RX reg.

                 000000

742       P:0017 0D0000  [4 -       60]            jsr     <goertzel                         ; process channel 5

743       P:0018 300000  [2 -       62]            move              #<ch6_mem,r0            ; set up data pointer for channel 6

744       P:0019 44F000  [4 -       66]            move              X:DTMF_IN+5,x0          ; read channel 6 data from RX reg.

                 000000

745       P:001B 0D0000  [4 -       70]            jsr     <goertzel                         ; process channel 6

746       P:001C 00000C  [4 -       74]            rts

747    

748    

749                                      ;*********************************************************************************************

750                                      ; Power calculation for dial tone detector

751                                      ; 

752                                      ; Calling Setup :

753                                      ;

754                                      ;              x0            :             contains log input data

Motorola DSP56000 Macro Cross Assembler  Version 2.01  89-02-13  11:20:35  goertzel.asm  Page 2







755                                      ;              r0            :             contains address of data tables for channel

756                                      ;

757                                      ; Perform one iteration of Goertzel algorithm on channel whose rows and columns are at

758                                      ; the addresses from (r0) (columns).  Input sample in x0.

759                                      ;

760                                      ; memory storage        :      y(n-1) in x:(r0), y(n-2) in y:(r0)

761                                      ;                                   Ck in y:(r5)

762                                      ;

763                                      ;***********************************************************************************************

764    

765       P:001D 468000  [2 -       76]  goertzel  move              x:<cshift,y0

766       P:001E 4580D0  [2 -       78]            mpy     x0,y0,a   x:<cmask,x1

767       P:001F 698066  [2 -       80]            and     x1,a                  y:<tab_val,r1

768       P:0020 219900  [2 -       82]            move              a1,n1

769       P:0021 057FA1  [2 -       84]            move              #<tab1,m1

770       P:0022 4C8057  [2 -       86]            cmpm    y0,a                  y:<win_val,x0 ; check sign to see about invert

771       P:0023 46E900  [4 -       90]            move              x:(r1+n1),y0            ; read value

772       P:0024 0E1000  [4 -       94]            jge     <_end_s                           ; do we need to invert? if so...

773       P:0025 3500D4  [2 -       96]            mpy     -x0,y0,a  #<coeffL1,r5            ; apply negative windowing function

774       P:0026 0C0000  [4 -      100]            jmp     <_endp                            ; and exit window stage

775       P:0027 3500D0  [2 -      102]  _end_s    mpy     x0,y0,a   #<coeffL1,r5            ; apply positive windowing function

776    

777       P:0028 21CF00  [2 -      104]  _endp     move              a,b                     ; save result of conversion

778       P:0029 45F400  [4 -      108]            move              #0.5,x1

                 400000

779       P:002B 0008F8  [2 -      110]            or      #8,mr                             ; enable scaling       

780    

781       P:002C 060880  [6 -      116]            do      #n_dtmf,_e_goert                  ; repeat for all n row/column tones

                 000031

782       P:002E 4EE001  [2 -      118]            tfr     b,a                   y:(r0),y0   ; fetch x(n) and y(n-2)

783       P:002F F0A0E6  [2 -      120]            mac     -x1,y0,a  x:(r0),x0   y:(r5)+,y0  ; form x(n)-y(n-2), fetch y(n-1) and Ck

784       P:0030 4C60D3  [2 -      122]            macr    x0,y0,a               x0,y:(r0)   ; form x(n)+b1*y(n-1)-2*y(n-2), save y(n-1)

785       P:0031 565800  [2 -      124]            move              a,x:(r0)+               ; save y(n)

786       P:0032 00F7B8  [2 -      126]  _e_goert  and     #$f7,mr                           ; disable scaling

787       P:0033 00000C  [4 -      130]            rts

788    

789    

790                                      ;*********************************************************************************************

791                                      ; Generate a data smoothing window coefficient - in this case, Hanning

792                                      ;

793                                      ; Result in y:win_val

794                                      ;

795                                      ; Should only be called when a window is definitely wanted.

796                                      ; Will clear "req_win" on exit, preventing further calls

797                                      ; unless explicitly requested.

798                                      ;

799                                      ; This generates the smoothing window used for all channels.

800                                      ;***********************************************************************************************

801    

Motorola DSP56000 Macro Cross Assembler  Version 2.01  89-02-13  11:20:35  goertzel.asm  Page 3







802       P:0034 4C8013  [2 -      132]  win_calc  clr     a                     y:<n_samps,x0 ; read position in window

803       P:0035 4D8000  [2 -      134]            move                          y:<win_scal,x1 ; read scale factor

804       P:0036 45F4A0  [4 -      138]            mpy     x1,x0,a   #$100,x1                ; scale window data, get number of points in table

                 000100

805    

806       P:0038 46F432  [4 -      142]            asl     a         #>$40,y0                ; start offset into table

                 000040

807       P:003A 46F450  [4 -      146]            add     y0,a      #>$ff,y0                ; add to form access offset

                 0000FF

808       P:003C 200056  [2 -      148]            and     y0,a                              ; limit to 8 bits

809       P:003D 200060  [2 -      150]            add     x1,a                              ; add table start address

810       P:003E 21D100  [2 -      152]            move              a,r1                    ; and use for access

811       P:003F 57F400  [4 -      156]            move              #0.5,b                  ; scale factor

                 400000

812       P:0041 5EE900  [4 -      160]            move                          y:(r1+n1),a ; read table entry

813       P:0042 200022  [2 -      162]            asr     a                                 ; divide by 2

814       P:0043 20001C  [2 -      164]            sub     a,b                               ; window function coefficient calculated

815       P:0044 1CF000  [4 -      168]            move              b,x1        y:fiddle,y0 ; shift into y0....

                 000000

816       P:0046 2000E0  [2 -      170]            mpy     x1,y0,a                           ; and scale coefficient

817       P:0047 5E0000  [2 -      172]            move                          a,y:<win_val

818       P:0048 00000C  [4 -      176]            rts

819    

820                                                endsec

821    

0    Errors

0    Warnings













































Motorola DSP56000 Macro Cross Assembler  Version 2.01  89-02-13  11:20:35  goertzel.asm  Page 4







                         Memory Utilization Report





X Memory



Start    End     Length    Type      Label             Section           Overlay Address

0000     FFFF    65536     UNUSED





Y Memory



Start    End     Length    Type      Label             Section           Overlay Address

0000     FFFF    65536     UNUSED





L Memory



Start    End     Length    Type      Label             Section           Overlay Address

0000     FFFF    65536     UNUSED





P Memory



Start    End     Length    Type      Label             Section           Overlay Address

0000     0048       73     CODE      goe_it            goertzel

0049     FFFF    65463     UNUSED















































_START x:e0..ef 

_COMMENT 

 **ADM0***



_DATA X e0

 5e9ae7 

 6d4b94 6d4b94 6d4b94 694c49 694c49 694c49 64655e 64655e 

 64655e 6d4b94 694c49 64655e 5e9ae7 5e9ae7 5e9ae7 

_END 

_START y:e0..ef 

_COMMENT 

 **ADM0***



_DATA Y e0

 3fc488

 4a80ae 3fc488 331c90 4a80ae 3fc488 331c90 4a80ae 3fc488

 331c90 2462d7 2462d7 2462d7 2462d7 331c90 4a80ae

_END 



		section		goertzel

		opt            mu,cc,mex,nomd

		include	'StdDefs'

		xdef		goe_it



;***********************************************************************************************

;

; Perform one iteration of Goertzel algorithm for four channels

;

;***********************************************************************************************



goe_it	jsr			<win_calc					; calculate	windowing function

		move		y:<n_samps,r1				; read number of samples since start

		move		#<ch1_mem,r0				; set up data pointer for channel 1

		move		x:DTMF_IN,x0				; read channel 1 data from RX reg. 

		move		(r1)+						;increment count

		move		r1,y:<n_samps				; store new count

		jsr			<goertzel					; process channel 1

		move		#<ch2_mem,r0				; set up data pointer for channel 2

		move		x:DTMF_IN+1,x0				; read channel 2 data from RX reg.

		jsr			<goertzel					; process channel 2

		move		#<ch3_mem,r0				; set up data pointer for channel 3

		move		x:DTMF_IN+2,x0				; read channel 3 data from RX reg.

		jsr			<goertzel					; process channel 3

		move		#<ch4_mem,r0				; set up data pointer for channel 4

		move		X:DTMF_IN+3,x0				; read channel 4 data from RX reg.

		jsr			<goertzel					; process channel 4

		move		#<ch5_mem,r0				; set up data pointer for channel 5

		move		X:DTMF_IN+4,x0				; read channel 5 data from RX reg.

		jsr			<goertzel					; process channel 5

		move		#<ch6_mem,r0				; set up data pointer for channel 6

		move		X:DTMF_IN+5,x0				; read channel 6 data from RX reg.

		jsr			<goertzel					; process channel 6

		rts





;*********************************************************************************************

; Power calculation for dial tone detector

; 

; Calling Setup :

;

;		x0		:		contains log input data

;		r0		:		contains address of data tables for channel

;

; Perform one iteration of Goertzel algorithm on channel whose rows and columns are at

; the addresses from (r0) (columns).  Input sample in x0.

;

; memory storage 	:	y(n-1) in x:(r0), y(n-2) in y:(r0)

; 					Ck in y:(r5)

;

;***********************************************************************************************



goertzel	move	x:<cshift,y0

			mpy		x0,y0,a         x:<cmask,x1

			and		x1,a            y:<tab_val,r1

			move	a1,n1

			move	#<tab1,m1

			cmpm	y0,a			y:<win_val,x0			; check sign to see about invert

			move	x:(r1+n1),y0							; read value

			jge		<_end_s									; do we need to invert? if so...

			mpy		-x0,y0,a	#<coeffL1,r5				; apply negative windowing function

			jmp		<_endp									; and exit window stage

_end_s		mpy		x0,y0,a		#<coeffL1,r5				; apply positive windowing function

		

_endp		move	a,b										; save result of conversion

			move	#0.5,x1	

			or		#8,mr									; enable scaling	



			do		#n_dtmf,_e_goert						; repeat for all n row/column tones

			tfr					b,a				y:(r0),y0 	; fetch x(n) and y(n-2)

			mac		-x1,y0,a	x:(r0),x0		y:(r5)+,y0	; form x(n)-y(n-2), fetch y(n-1) and Ck

			macr	x0,y0,a		x0,y:(r0)					; form x(n)+b1*y(n-1)-2*y(n-2), save y(n-1)

			move	a,x:(r0)+								; save y(n)

_e_goert	and		#$f7,mr									; disable scaling

			rts

			



;*********************************************************************************************

; Generate a data smoothing window coefficient - in this case, Hanning

;

; Result in y:win_val

;

; Should only be called when a window is definitely wanted.

; Will clear "req_win" on exit, preventing further calls

; unless explicitly requested.

;

; This generates the smoothing window used for all channels.

;***********************************************************************************************



win_calc	clr		a			y:<n_samps,x0	; read position in window

			move	y:<win_scal,x1				; read scale factor

			mpy		x1,x0,a		#$100,x1		; scale window data, get number of points in table

			

			asl		a			#>$40,y0		; start offset into table

			add		y0,a		#>$ff,y0		; add to form access offset

			and		y0,a						; limit to 8 bits

			add		x1,a						; add table start address

			move	a,r1						; and use for access

			move	#0.5,b						; scale factor

			move	y:(r1+n1),a					; read table entry

			asr		a							; divide by 2

			sub		a,b							; window function coefficient calculated

			move	b,x1		y:fiddle,y0	; shift into y0....

			mpy		x1,y0,a						; and scale coefficient

			move	a,y:<win_val

			rts



			endsec

			

_START GOERTZEL 0001 0000 0000



_SECTION GLOBAL R 0000

0000 0000 0000 0000 0000 0000

0000 0000 0000 0000 0000 0000

_SECTION goertzel R 0001

0000 0000 0000 0000 0000 0000

0000 0000 0000 0049 0000 0000

_SYMBOL 0001 N

BT_dtmin         LAF 0.000010     

Fs               LAF 8000.000000  

M_BCR            LAI 0000FFFE

M_CD             LAI 00000FFF

M_COD            LAI 0000000C

M_CRA            LAI 0000FFEC

M_CRB            LAI 0000FFED

M_DC             LAI 00001F00

M_DMA            LAI 00000007

M_FE             LAI 00000006

M_FSL            LAI 00000008

M_GCK            LAI 0000000A

M_HCIE           LAI 00000002

M_HCP            LAI 00000002

M_HCR            LAI 0000FFE8

M_HF             LAI 00000018

M_HF0            LAI 00000003

M_HF1            LAI 00000004

M_HF2            LAI 00000003

M_HF3            LAI 00000004

M_HPL            LAI 00000C00

M_HPL0           LAI 0000000A

M_HPL1           LAI 0000000B

M_HRDF           LAI 00000000

M_HRIE           LAI 00000000

M_HRX            LAI 0000FFEB

M_HSR            LAI 0000FFE9

M_HTDE           LAI 00000001

M_HTIE           LAI 00000001

M_HTX            LAI 0000FFEB

M_IAL            LAI 00000007

M_IAL0           LAI 00000000

M_IAL1           LAI 00000001

M_IAL2           LAI 00000002

M_IBL            LAI 00000038

M_IBL0           LAI 00000003

M_IBL1           LAI 00000004

M_IBL2           LAI 00000005

M_IDLE           LAI 00000003

M_IF             LAI 00000002

M_IF0            LAI 00000000

M_IF1            LAI 00000001

M_ILIE           LAI 0000000A

M_IPR            LAI 0000FFFF

M_MOD            LAI 0000000B

M_OF             LAI 00000003

M_OF0            LAI 00000000

M_OF1            LAI 00000001

M_OR             LAI 00000004

M_PBC            LAI 0000FFE0

M_PBD            LAI 0000FFE4

M_PBDDR          LAI 0000FFE2

M_PCC            LAI 0000FFE1

M_PCD            LAI 0000FFE5

M_PCDDR          LAI 0000FFE3

M_PE             LAI 00000005

M_PM             LAI 000000FF

M_PSR            LAI 0000000F

M_R8             LAI 00000007

M_RCM            LAI 0000000E

M_RDF            LAI 00000007

M_RDRF           LAI 00000002

M_RE             LAI 00000008

M_RFS            LAI 00000003

M_RIE            LAI 0000000B

M_ROE            LAI 00000005

M_RWI            LAI 00000006

M_RX             LAI 0000FFEF

M_SBK            LAI 00000004

M_SCCR           LAI 0000FFF2

M_SCD            LAI 0000001C

M_SCD0           LAI 00000002

M_SCD1           LAI 00000003

M_SCD2           LAI 00000004

M_SCKD           LAI 00000005

M_SCL            LAI 0000C000

M_SCL0           LAI 0000000E

M_SCL1           LAI 0000000F

M_SCP            LAI 0000000D

M_SCR            LAI 0000FFF0

M_SR             LAI 0000FFEE

M_SRE            LAI 0000000D

M_SRIE           LAI 0000000F

M_SRXH           LAI 0000FFF6

M_SRXL           LAI 0000FFF4

M_SRXM           LAI 0000FFF5

M_SSL            LAI 00003000

M_SSL0           LAI 0000000C

M_SSL1           LAI 0000000D

M_SSR            LAI 0000FFF1

M_STE            LAI 0000000C

M_STIE           LAI 0000000E

M_STXA           LAI 0000FFF3

M_STXH           LAI 0000FFF6

M_STXL           LAI 0000FFF4

M_STXM           LAI 0000FFF5

M_SYN            LAI 00000009

M_TCM            LAI 0000000F

M_TDE            LAI 00000006

M_TDRE           LAI 00000001

M_TE             LAI 00000009

M_TFS            LAI 00000002

M_TIE            LAI 0000000C

M_TMIE           LAI 0000000D

M_TRNE           LAI 00000000

M_TSR            LAI 0000FFEE

M_TUE            LAI 00000004

M_TX             LAI 0000FFEF

M_WAKE           LAI 00000005

M_WDS            LAI 00000003

M_WDS0           LAI 00000000

M_WDS1           LAI 00000001

M_WDS2           LAI 00000002

M_WL             LAI 00006000

M_WL0            LAI 0000000D

M_WL1            LAI 0000000E

M_WOMS           LAI 00000007

M_dtmax          LAF 0.158489     

M_dtmin          LAF 0.000010     

N                LAI 000000CD

dt_code          LAI 00001919

fbtdt_1          LAI 00000021

fbtdt_2a         LAI 0000015E

fbtdt_2b         LAI 000001B8

fcol1            LAI 000004B9

fcol2            LAI 00000538

fcol3            LAI 000005C5

fcol4            LAI 00000661

fmercdt1         LAI 00000457

frow1            LAI 000002B9

frow2            LAI 00000302

frow3            LAI 00000354

frow4            LAI 000003AD

mask             LAI 0000007F

mi4dB            LAF 0.398107     

mi6dB            LAF 0.251189     

mi8dB            LAF 0.158489     

n_dtmf           LAI 00000008

pi               LAF 3.141593     

shift            LAI 00000080

space            LAI 000000FF

tab1             LAI 0000007F

tmin             LAF 0.000016     

_SYMBOL 0001 P

goe_it           GRI 00000000

goertzel         LRI 0000001D

win_calc         LRI 00000034

_DATA 0001 P 0000

(($0D0000&~(~(~0<<12)<<0))|(({win_calc}@15&~(~0<<12))<<0)) 

(($698000&~(~(~0<<6)<<8))|(({n_samps}@16&~(~0<<6))<<8)) 

(($300000&~(~(~0<<8)<<8))|(({ch1_mem}@11&~(~0<<8))<<8)) $44F000 {DTMF_IN}@0 

$205900 (($690000&~(~(~0<<6)<<8))|(({n_samps}@16&~(~0<<6))<<8)) 

(($0D0000&~(~(~0<<12)<<0))|(({goertzel}@15&~(~0<<12))<<0)) 

(($300000&~(~(~0<<8)<<8))|(({ch2_mem}@11&~(~0<<8))<<8)) $44F000 {DTMF_IN+1}@0 

(($0D0000&~(~(~0<<12)<<0))|(({goertzel}@15&~(~0<<12))<<0)) 

(($300000&~(~(~0<<8)<<8))|(({ch3_mem}@11&~(~0<<8))<<8)) $44F000 {DTMF_IN+2}@0 

(($0D0000&~(~(~0<<12)<<0))|(({goertzel}@15&~(~0<<12))<<0)) 

(($300000&~(~(~0<<8)<<8))|(({ch4_mem}@11&~(~0<<8))<<8)) $44F000 {DTMF_IN+3}@0 

(($0D0000&~(~(~0<<12)<<0))|(({goertzel}@15&~(~0<<12))<<0)) 

(($300000&~(~(~0<<8)<<8))|(({ch5_mem}@11&~(~0<<8))<<8)) $44F000 {DTMF_IN+4}@0 

(($0D0000&~(~(~0<<12)<<0))|(({goertzel}@15&~(~0<<12))<<0)) 

(($300000&~(~(~0<<8)<<8))|(({ch6_mem}@11&~(~0<<8))<<8)) $44F000 {DTMF_IN+5}@0 

(($0D0000&~(~(~0<<12)<<0))|(({goertzel}@15&~(~0<<12))<<0)) $00000C 

(($468000&~(~(~0<<6)<<8))|(({cshift}@16&~(~0<<6))<<8)) 

(($4580D0&~(~(~0<<6)<<8))|(({cmask}@16&~(~0<<6))<<8)) 

(($698066&~(~(~0<<6)<<8))|(({tab_val}@16&~(~0<<6))<<8)) $219900 $057FA1 

(($4C8057&~(~(~0<<6)<<8))|(({win_val}@16&~(~0<<6))<<8)) $46E900 

(($0E1000&~(~(~0<<12)<<0))|(({[$00000027]}@15&~(~0<<12))<<0)) 

(($3500D4&~(~(~0<<8)<<8))|(({coeffL1}@11&~(~0<<8))<<8)) 

(($0C0000&~(~(~0<<12)<<0))|(({[$00000028]}@15&~(~0<<12))<<0)) 

(($3500D0&~(~(~0<<8)<<8))|(({coeffL1}@11&~(~0<<8))<<8)) $21CF00 $45F400 

$400000 $0008F8 $060880 {[$00000032]}@0-1 $4EE001 $F0A0E6 $4C60D3 $565800 

$00F7B8 $00000C (($4C8013&~(~(~0<<6)<<8))|(({n_samps}@16&~(~0<<6))<<8)) 

(($4D8000&~(~(~0<<6)<<8))|(({win_scal}@16&~(~0<<6))<<8)) $45F4A0 $000100 

$46F432 $000040 $46F450 $0000FF $200056 $200060 $21D100 $57F400 $400000 

$5EE900 $200022 $20001C $1CF000 {fiddle}@0 $2000E0 

(($5E0000&~(~(~0<<6)<<8))|(({win_val}@16&~(~0<<6))<<8)) $00000C 

_XREF 0001

DTMF_IN

ch1_mem

ch2_mem

ch3_mem

ch4_mem

ch5_mem

ch6_mem

cmask

coeffL1

cshift

fiddle

n_samps

tab_val

win_scal

win_val

_END $0000

Motorola DSP56000 Macro Cross Assembler  Version 2.01  89-02-13  11:20:35  goertzel.asm  Page 1







1      

2                                  section goertzel

3                                                  opt     mu,cc,mex,nomd

4                                                  include 'StdDefs'

716                                                xdef    goe_it

717    

718                                      ;***********************************************************************************************

719                                      ;

720                                      ; Perform one iteration of Goertzel algorithm for four channels

721                                      ;

722                                      ;***********************************************************************************************

723    

724       P:0000 0D0000  [4 -        4]  goe_it    jsr     <win_calc                         ; calculate    windowing function

725       P:0001 698000  [2 -        6]            move                          y:<n_samps,r1 ; read number of samples since start

726       P:0002 300000  [2 -        8]            move              #<ch1_mem,r0            ; set up data pointer for channel 1

727       P:0003 44F000  [4 -       12]            move              x:DTMF_IN,x0            ; read channel 1 data from RX reg. 

                 000000

728       P:0005 205900  [2 -       14]            move              (r1)+                   ;increment count

729       P:0006 690000  [2 -       16]            move                          r1,y:<n_samps ; store new count

730       P:0007 0D0000  [4 -       20]            jsr     <goertzel                         ; process channel 1

731       P:0008 300000  [2 -       22]            move              #<ch2_mem,r0            ; set up data pointer for channel 2

732       P:0009 44F000  [4 -       26]            move              x:DTMF_IN+1,x0          ; read channel 2 data from RX reg.

                 000000

733       P:000B 0D0000  [4 -       30]            jsr     <goertzel                         ; process channel 2

734       P:000C 300000  [2 -       32]            move              #<ch3_mem,r0            ; set up data pointer for channel 3

735       P:000D 44F000  [4 -       36]            move              x:DTMF_IN+2,x0          ; read channel 3 data from RX reg.

                 000000

736       P:000F 0D0000  [4 -       40]            jsr     <goertzel                         ; process channel 3

737       P:0010 300000  [2 -       42]            move              #<ch4_mem,r0            ; set up data pointer for channel 4

738       P:0011 44F000  [4 -       46]            move              X:DTMF_IN+3,x0          ; read channel 4 data from RX reg.

                 000000

739       P:0013 0D0000  [4 -       50]            jsr     <goertzel                         ; process channel 4

740       P:0014 300000  [2 -       52]            move              #<ch5_mem,r0            ; set up data pointer for channel 5

741       P:0015 44F000  [4 -       56]            move              X:DTMF_IN+4,x0          ; read channel 5 data from RX reg.

                 000000

742       P:0017 0D0000  [4 -       60]            jsr     <goertzel                         ; process channel 5

743       P:0018 300000  [2 -       62]            move              #<ch6_mem,r0            ; set up data pointer for channel 6

744       P:0019 44F000  [4 -       66]            move              X:DTMF_IN+5,x0          ; read channel 6 data from RX reg.

                 000000

745       P:001B 0D0000  [4 -       70]            jsr     <goertzel                         ; process channel 6

746       P:001C 00000C  [4 -       74]            rts

747    

748    

749                                      ;*********************************************************************************************

750                                      ; Power calculation for dial tone detector

751                                      ; 

752                                      ; Calling Setup :

753                                      ;

754                                      ;              x0            :             contains log input data

Motorola DSP56000 Macro Cross Assembler  Version 2.01  89-02-13  11:20:35  goertzel.asm  Page 2







755                                      ;              r0            :             contains address of data tables for channel

756                                      ;

757                                      ; Perform one iteration of Goertzel algorithm on channel whose rows and columns are at

758                                      ; the addresses from (r0) (columns).  Input sample in x0.

759                                      ;

760                                      ; memory storage        :      y(n-1) in x:(r0), y(n-2) in y:(r0)

761                                      ;                                   Ck in y:(r5)

762                                      ;

763                                      ;***********************************************************************************************

764    

765       P:001D 468000  [2 -       76]  goertzel  move              x:<cshift,y0

766       P:001E 4580D0  [2 -       78]            mpy     x0,y0,a   x:<cmask,x1

767       P:001F 698066  [2 -       80]            and     x1,a                  y:<tab_val,r1

768       P:0020 219900  [2 -       82]            move              a1,n1

769       P:0021 057FA1  [2 -       84]            move              #<tab1,m1

770       P:0022 4C8057  [2 -       86]            cmpm    y0,a                  y:<win_val,x0 ; check sign to see about invert

771       P:0023 46E900  [4 -       90]            move              x:(r1+n1),y0            ; read value

772       P:0024 0E1000  [4 -       94]            jge     <_end_s                           ; do we need to invert? if so...

773       P:0025 3500D4  [2 -       96]            mpy     -x0,y0,a  #<coeffL1,r5            ; apply negative windowing function

774       P:0026 0C0000  [4 -      100]            jmp     <_endp                            ; and exit window stage

775       P:0027 3500D0  [2 -      102]  _end_s    mpy     x0,y0,a   #<coeffL1,r5            ; apply positive windowing function

776    

777       P:0028 21CF00  [2 -      104]  _endp     move              a,b                     ; save result of conversion

778       P:0029 45F400  [4 -      108]            move              #0.5,x1

                 400000

779       P:002B 0008F8  [2 -      110]            or      #8,mr                             ; enable scaling       

780    

781       P:002C 060880  [6 -      116]            do      #n_dtmf,_e_goert                  ; repeat for all n row/column tones

                 000031

782       P:002E 4EE001  [2 -      118]            tfr     b,a                   y:(r0),y0   ; fetch x(n) and y(n-2)

783       P:002F F0A0E6  [2 -      120]            mac     -x1,y0,a  x:(r0),x0   y:(r5)+,y0  ; form x(n)-y(n-2), fetch y(n-1) and Ck

784       P:0030 4C60D3  [2 -      122]            macr    x0,y0,a               x0,y:(r0)   ; form x(n)+b1*y(n-1)-2*y(n-2), save y(n-1)

785       P:0031 565800  [2 -      124]            move              a,x:(r0)+               ; save y(n)

786       P:0032 00F7B8  [2 -      126]  _e_goert  and     #$f7,mr                           ; disable scaling

787       P:0033 00000C  [4 -      130]            rts

788    

789    

790                                      ;*********************************************************************************************

791                                      ; Generate a data smoothing window coefficient - in this case, Hanning

792                                      ;

793                                      ; Result in y:win_val

794                                      ;

795                                      ; Should only be called when a window is definitely wanted.

796                                      ; Will clear "req_win" on exit, preventing further calls

797                                      ; unless explicitly requested.

798                                      ;

799                                      ; This generates the smoothing window used for all channels.

800                                      ;***********************************************************************************************

801    

Motorola DSP56000 Macro Cross Assembler  Version 2.01  89-02-13  11:20:35  goertzel.asm  Page 3







802       P:0034 4C8013  [2 -      132]  win_calc  clr     a                     y:<n_samps,x0 ; read position in window

803       P:0035 4D8000  [2 -      134]            move                          y:<win_scal,x1 ; read scale factor

804       P:0036 45F4A0  [4 -      138]            mpy     x1,x0,a   #$100,x1                ; scale window data, get number of points in table

                 000100

805    

806       P:0038 46F432  [4 -      142]            asl     a         #>$40,y0                ; start offset into table

                 000040

807       P:003A 46F450  [4 -      146]            add     y0,a      #>$ff,y0                ; add to form access offset

                 0000FF

808       P:003C 200056  [2 -      148]            and     y0,a                              ; limit to 8 bits

809       P:003D 200060  [2 -      150]            add     x1,a                              ; add table start address

810       P:003E 21D100  [2 -      152]            move              a,r1                    ; and use for access

811       P:003F 57F400  [4 -      156]            move              #0.5,b                  ; scale factor

                 400000

812       P:0041 5EE900  [4 -      160]            move                          y:(r1+n1),a ; read table entry

813       P:0042 200022  [2 -      162]            asr     a                                 ; divide by 2

814       P:0043 20001C  [2 -      164]            sub     a,b                               ; window function coefficient calculated

815       P:0044 1CF000  [4 -      168]            move              b,x1        y:fiddle,y0 ; shift into y0....

                 000000

816       P:0046 2000E0  [2 -      170]            mpy     x1,y0,a                           ; and scale coefficient

817       P:0047 5E0000  [2 -      172]            move                          a,y:<win_val

818       P:0048 00000C  [4 -      176]            rts

819    

820                                                endsec

821    

0    Errors

0    Warnings













































Motorola DSP56000 Macro Cross Assembler  Version 2.01  89-02-13  11:20:35  goertzel.asm  Page 4







                         Memory Utilization Report





X Memory



Start    End     Length    Type      Label             Section           Overlay Address

0000     FFFF    65536     UNUSED





Y Memory



Start    End     Length    Type      Label             Section           Overlay Address

0000     FFFF    65536     UNUSED





L Memory



Start    End     Length    Type      Label             Section           Overlay Address

0000     FFFF    65536     UNUSED





P Memory



Start    End     Length    Type      Label             Section           Overlay Address

0000     0048       73     CODE      goe_it            goertzel

0049     FFFF    65463     UNUSED















































load test

load data

load genxd

load genyd




Instructions for using the DTMF Preliminary data on this disk:

You must assemble and link the following files to run the single 
channel detect and receive DTMF routine:
dtmf, det, sub
You can do this by typing the following:
ex56 test dtmf det sub
This will create test.lod which will be you load file.
After entering ADS you will type "load" to run the load cmd.
You then need to type "clear" to clear the pointers.
You will now be ready to go by typing "go"

As stated previously, all of this data is preliminary and may be used
on an "as is"  basis.

You may use the multichannel version by linking with dtmfmstr instead
of dtmf.  This version is receive only.



	title	'SUBROUTINES '

	page	132,66,0,10





;************************************************************************

;This section contains miscellaneous subroutines for input and output

;as well computing energies in esch tone.

;************************************************************************



sub	IDENT	1,1

	section	sub

	xdef	iiraspi,rdlgln,ready,enerac

        opt     rc,mu,cc

	nolist

	include '\dsp56000.asm\ioequ'        

	list

	org	phi:

;

;*************

; write READY 

;*************

ready	move	x:(r0)+,x0

	do	n0,_fin

	movep	x0,x:M_STXL	;write in sci tx low byte

att	jclr	#M_TDRE,x:M_SSR,att	;wait for tx empty

	move	x:(r0)+,x0

_fin	rts

;

;**********

;  IIRASPI

;**********

;	Equation of the filter:

;	y(n) = b0*x(n) +w1(n-1)

;	w1(n)= b1*x(n) -a1*y(n) +w2(n-1)

;	w2(n)= b2*x(n) -a2*y(n)

;

;	Implemented in that way:

;	y(n)/2 = b0/2*x(n) +w1(n-1)/2

;	w1(n)/2= b1/2*x(n) -a1/2*y(n) +w2(n-1)/2

;	w2(n)/2= b2/2*x(n) -a2/2*y(n)

;

;	r0 -> X:xddr 

;	r4 -> Y:cddr 

;       n0 = number of cells = filter order/2

;

iiraspi	do	n0,_iirend	

	move	a,x0

	move	x:(r0)+,a y:(r4)+,y0		; a=w1n-1 x0=xn y0=b0

	mac	x0,y0,a	  x:(r0)-,b  y:(r4)+,y0 ; a=yn b=w2n-1 y0=b1

	asl	a

	mac	x0,y0,b   a,x1	     y:(r4)+,y0	; x1=yn y0=a1

	mac	-x1,y0,b 	     y:(r4)+,y0 ; y0=a2 b=w1n

	mpy     -x1,y0,a  b,x:(r0)+  y:(r4)+,y0 ; y0=b2

	mac	x0,y0,a				; a=w2n	     

	tfr	x1,a      a,x:(r0)+ 

_iirend	rts

;

;************************************

;  linear expansion

; uses a,x0,y0,x1,r3,n3,m3

;

; data for log/lin conversion routines

;************************************* 



inv     equ     $d5     ;invert even bits+sign 

msk13   equ     $fff800 ;mask  13 msb 

shift   equ     $80

mask    equ     $7f

tab     equ     $180 	;A law table address in DS56001 X ROM.

tab1	equ	$7f	;modulo value

;

rdlgln	

_wrdf	jclr	#M_RDF,x:M_SR,_wrdf	; wait for rdf

        movep   x:M_RX,x0               ; read data 

	move    #>shift,y0

        mpy     x0,y0,a         #>mask,x1

        and     x1,a            #tab,r3

	move	a1,n3

        move	#tab1,m3

	cmpm	y0,a	

	move	x:(r3+n3),a

	jge	<endp

        neg     a

endp	rts  

;

;************************************

;	energy computation subroutine

;************************************



enerac	move	a,x0	y:(r6),y0	; compute a*a/80

	mpy	x0,y0,a			; a=a/80

	move	a,y0

	mpy	x0,y0,a	x:(r2),b	;a=a*a/80

	add	b,a			;accumulate

	move 	a,x:(r2)+		;update

	rts

;

	endsec 



	end



















; memory file controls the linker for the Goertzel DTMF detector test programme

; tabgen must be a modulo-4 base address for proper operation



symbol		tabgen	$40



base		xi:$00,yi:$00,li:$c0,pi:$10

section 	vectors	p:0

section		tonegen		x:$30,y:$30

section		bridge 		x:$78,y:$78

section 	dialtone	x:$a0,y:$a0

section		MIT_8920	x:$2000,y:$2000,l:$2000

section 	fifo		x:$90

